<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <link rel="icon" type="image/x-icon" href="https://res.cloudinary.com/djttn4xvk/image/upload/v1744016662/iv8s8dkwdzxgnubsnhla.ico"> <!-- Added Favicon Back -->
    <style>
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722;
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
            --green-live: #2ecc71; /* Added live indicator color */
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; }
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        h1, h2 { color: var(--orange); }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.6;} /* Style for disabled button */
        #logout-button { background-color: #555; }
        .admin-section { margin-top: 20px; border-top: 1px solid #444; padding-top: 20px; }
        label { display: block; margin-bottom: 5px; color: var(--text-secondary); }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select { /* Added select */
            width: calc(95% - 18px); /* Adjust width considering padding/border */
            padding: 8px;
            margin-bottom: 10px;
            background-color: #333;
            border: 1px solid #555;
            color: var(--text);
            border-radius: 4px;
        }
        input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }
        label[for] {
            cursor: pointer; /* Indicate checkbox label is clickable */
        }

        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); }

        .match-editor, .player-editor {
             margin-bottom: 15px; padding: 10px; border: 1px dashed #555; border-radius: 5px;
        }

        /* --- Bracket Editor Styles --- */
        #bracket-editor { display: flex; overflow-x: auto; padding-bottom: 15px; gap: 20px; }
        .bracket-round-column { flex: 0 0 300px; min-width: 250px; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: var(--dark-accent); display: flex; flex-direction: column; gap: 15px; }
        .bracket-round-column h4 { margin-top: 0; padding-bottom: 10px; border-bottom: 1px dashed #555; display: flex; justify-content: space-between; align-items: center; }
        .bracket-round-column h4 input[type="text"] { flex-grow: 1; margin-right: 10px; padding: 5px; width: auto; }
        .bracket-match-editor { padding: 10px; border: 1px solid #555; border-radius: 4px; background-color: var(--dark); display: flex; flex-direction: column; gap: 5px; }
        .bracket-match-editor h5 { margin-top: 0; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; font-size: 1em; }
        .bracket-match-editor h5 button { padding: 3px 8px; font-size: 0.8em; margin: 0; background-color: #c0392b; }
        .bracket-round-column h4 button { padding: 3px 8px; font-size: 0.8em; margin: 0; background-color: #c0392b; }
        .bracket-match-editor label { font-size: 0.9em; margin-bottom: 0; }
        .bracket-match-editor input[type="text"], .bracket-match-editor input[type="number"] { width: calc(100% - 18px); padding: 4px; margin-bottom: 5px; font-size: 0.9em; }
        .bracket-match-editor .checkbox-label { display: flex; align-items: center; margin-top: 5px; font-size: 0.9em; }
        .bracket-match-editor .checkbox-label input[type="checkbox"] { margin-right: 5px; margin-bottom: 0; }
        .bracket-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid #444; }
        .bracket-controls button { margin-right: 10px; }
        .loading-indicator { font-style: italic; color: var(--text-secondary); padding: 10px; text-align: center; width: 100%; box-sizing: border-box; }
        /* --- End Bracket Editor Styles --- */

        /* --- START: Online Users Presence Styles --- */
        #online-users-section { margin-bottom: 20px; padding: 15px; background-color: var(--dark-accent); border-radius: 8px; border: 1px solid #444; }
        #online-users-section h4 { margin-top: 0; margin-bottom: 15px; color: var(--text-secondary); font-size: 0.9em; font-weight: normal; border-bottom: 1px dashed #555; padding-bottom: 10px; }
        #online-users-container { display: flex; flex-wrap: wrap; gap: 20px; }
        .user-presence-indicator { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .user-presence-circle { width: 40px; height: 40px; border-radius: 50%; background-color: var(--orange); color: var(--dark); display: flex; align-items: center; justify-content: center; font-size: 1.2em; font-weight: bold; margin-bottom: 5px; border: 3px solid transparent; box-sizing: border-box; text-transform: uppercase; }
        .user-presence-circle.live { border-color: var(--green-live); }
        .user-presence-name { font-size: 0.8em; color: var(--text-secondary); max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        /* --- END: Online Users Presence Styles --- */

    </style>
</head>
<body>

<h1>Poxel Competitive - Admin</h1>

<!-- Login Section -->
<div id="login-container">
    <h2>Admin Login</h2>
    <p>Please log in with your authorized Google account.</p>
    <button id="login-button">Login with Google</button>
    <p id="login-error" style="color: red;"></p>
    <p id="auth-check-message" style="color: orange;"></p>
</div>

<!-- Admin Panel (Initially Hidden) -->
<div id="admin-panel" class="hidden">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2>Management Dashboard</h2>
        <div>
            <span id="user-info" style="margin-right: 15px;"></span>
            <button id="logout-button">Logout</button>
        </div>
    </div>

    <!-- START: Online Users Section -->
    <div id="online-users-section">
        <h4>Online Admins:</h4>
        <div id="online-users-container">
            <div class="loading-indicator">Loading presence...</div>
            <!-- Online users will be rendered here -->
        </div>
    </div>
    <!-- END: Online Users Section -->

    <p style="color: lightgreen;" id="save-status"></p>

    <!-- Upcoming Matches Management -->
    <div class="admin-section">
        <h3>Upcoming Matches Management</h3>
        <div id="matches-list"></div>
        <button id="add-match-button">Add New Match</button>
        <div id="add-match-form" class="match-editor hidden">
             <h4>New Match Details</h4>
             <label for="new-match-date">Date & Time:</label>
             <input type="datetime-local" id="new-match-date">
             <label for="new-match-type">Type (e.g., Quarterfinals):</label>
             <input type="text" id="new-match-type">
             <label for="new-match-team1-name">Team 1 Name:</label>
             <input type="text" id="new-match-team1-name">
             <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
             <input type="text" id="new-match-team1-logo" maxlength="2">
             <label for="new-match-team2-name">Team 2 Name:</label>
             <input type="text" id="new-match-team2-name">
             <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
             <input type="text" id="new-match-team2-logo" maxlength="2">
             <label for="new-match-venue">Venue:</label>
             <input type="text" id="new-match-venue">
             <label for="new-match-stream">Stream Link:</label>
             <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
             <button id="save-new-match">Save New Match</button>
             <button type="button" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
        </div>
        <button id="save-matches-changes">Save All Match Changes</button>
    </div>

    <!-- Leaderboard Management -->
    <div class="admin-section">
        <h3>Leaderboard Management</h3>
        <div id="leaderboard-list">
             <table>
                 <thead>
                     <tr>
                         <th>Rank</th><th>Player Name</th><th>Avatar</th><th>Matches</th><th>Wins</th><th>Losses</th><th>Points</th><th>Actions</th>
                     </tr>
                 </thead>
                 <tbody id="leaderboard-body-admin"></tbody>
             </table>
        </div>
         <button id="add-player-button">Add New Player</button>
         <div id="add-player-form" class="player-editor hidden">
             <h4>New Player Details</h4>
             <label>Name:</label><input type="text" id="new-player-name">
             <label>Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
             <label>Matches:</label><input type="number" id="new-player-matches" value="0" min="0">
             <label>Wins:</label><input type="number" id="new-player-wins" value="0" min="0">
             <label>Losses:</label><input type="number" id="new-player-losses" value="0" min="0">
             <label>Points:</label><input type="number" id="new-player-points" value="0">
             <button id="save-new-player">Save New Player</button>
             <button type="button" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
        </div>
        <button id="save-leaderboard-changes">Save Leaderboard Changes</button>
    </div>

    <!-- Tournament Bracket Management -->
    <div class="admin-section">
        <h3>Tournament Bracket Management</h3>
        <label for="bracket-select">Select Bracket:</label>
        <select id="bracket-select">
            <option value="pro">Pro Tourney</option>
            <option value="novice">Novice Tourney</option>
        </select>
         <div id="bracket-loading-indicator" class="loading-indicator hidden">Loading...</div>
        <div id="bracket-editor"></div>
        <div class="bracket-controls">
             <button id="add-round-button">Add New Round</button>
             <button id="save-bracket-changes">Save Bracket Changes</button>
              <p><i>Note: This view arranges rounds horizontally...</i></p>
        </div>
    </div>

</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

<script>
    // =========================================================================
    // --- SCRIPT START ---
    // =========================================================================

    const firebaseConfig = {
          apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI", // Replace with your actual config if different
          authDomain: "poxelcomp.firebaseapp.com",
          projectId: "poxelcomp",
          storageBucket: "poxelcomp.firebasestorage.app",
          messagingSenderId: "620490990104",
          appId: "1:620490990104:web:709023eb464c7d886b996d",
    };

    // --- Initialize Firebase ---
    if (!firebase.apps.length) { // Initialize only once
        firebase.initializeApp(firebaseConfig);
    }
    const auth = firebase.auth();
    const db = firebase.firestore();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // --- DOM Elements ---
    const loginContainer = document.getElementById('login-container');
    const adminPanel = document.getElementById('admin-panel');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userInfo = document.getElementById('user-info');
    const loginError = document.getElementById('login-error');
    const authCheckMessage = document.getElementById('auth-check-message');
    const saveStatus = document.getElementById('save-status');
    const onlineUsersContainer = document.getElementById('online-users-container');
    const matchesList = document.getElementById('matches-list');
    const addMatchButton = document.getElementById('add-match-button');
    const addMatchForm = document.getElementById('add-match-form');
    const saveNewMatchButton = document.getElementById('save-new-match');
    const saveMatchesChangesButton = document.getElementById('save-matches-changes');
    const leaderboardList = document.getElementById('leaderboard-list');
    const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
    const addPlayerButton = document.getElementById('add-player-button');
    const addPlayerForm = document.getElementById('add-player-form');
    const saveNewPlayerButton = document.getElementById('save-new-player');
    const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');
    const bracketSelect = document.getElementById('bracket-select');
    const bracketEditor = document.getElementById('bracket-editor');
    const bracketLoadingIndicator = document.getElementById('bracket-loading-indicator');
    const addRoundButton = document.getElementById('add-round-button');
    const saveBracketChangesButton = document.getElementById('save-bracket-changes');

    // --- Global State ---
    let currentBracketData = { rounds: [] };
    let currentBracketType = 'pro';
    let currentUserId = null; // UID of the currently logged-in admin
    let presenceUpdateInterval = null;
    let onlineUsersListenerUnsubscribe = null;

    // =========================================================================
    // --- Core Functions ---
    // =========================================================================

    // --- Authorization Check ---
    async function checkAdminAuthorization(uid) {
        if (!uid) return false; // Cannot authorize null user
        console.log(`Checking authorization for UID: ${uid}`);
        authCheckMessage.textContent = 'Checking authorization...';
        authCheckMessage.style.color = 'orange';
        try {
            const adminDocRef = db.collection('admins').doc(uid);
            const adminDoc = await adminDocRef.get();

            if (adminDoc.exists) {
                console.log(`UID ${uid} IS authorized.`);
                authCheckMessage.textContent = ''; // Clear message on success
                return true;
            } else {
                console.log(`UID ${uid} is NOT authorized.`);
                authCheckMessage.textContent = 'Access Denied: Your account is not authorized.';
                authCheckMessage.style.color = 'red';
                return false;
            }
        } catch (error) {
            console.error("Error checking admin authorization:", error);
            authCheckMessage.textContent = `Authorization check error: ${error.message}`;
            authCheckMessage.style.color = 'red';
            return false;
        }
    }

    // --- Presence Management ---
    const PRESENCE_COLLECTION = 'online_users';
    const PRESENCE_TIMEOUT_MS = 90 * 1000;
    const PRESENCE_UPDATE_INTERVAL_MS = 60 * 1000;

    async function registerPresence(user) {
        if (!user || !user.uid) return;
        currentUserId = user.uid; // Set global admin UID
        const presenceRef = db.collection(PRESENCE_COLLECTION).doc(user.uid);
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName || user.email.split('@')[0],
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        };
        try {
            console.log(`Registering presence for ${user.email}`);
            await presenceRef.set(userData, { merge: true });
            if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
            presenceUpdateInterval = setInterval(async () => {
                if (auth.currentUser && auth.currentUser.uid === currentUserId) {
                    try {
                        await presenceRef.update({ lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
                    } catch (error) { console.error("Error updating presence:", error); clearInterval(presenceUpdateInterval); }
                } else { clearInterval(presenceUpdateInterval); }
            }, PRESENCE_UPDATE_INTERVAL_MS);
            listenForOnlineAdmins();
        } catch (error) {
            console.error("Error registering presence:", error);
            if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:red;">Error setting up presence.</div>';
        }
    }

    async function removePresence(uid) {
        if (!uid) return;
        console.log(`Removing presence for UID: ${uid}`);
        if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
        if (onlineUsersListenerUnsubscribe) onlineUsersListenerUnsubscribe();
        presenceUpdateInterval = null; onlineUsersListenerUnsubscribe = null;
        try {
            await db.collection(PRESENCE_COLLECTION).doc(uid).delete();
            console.log(`Presence document deleted for ${uid}`);
        } catch (error) { console.error("Error removing presence document:", error); }
        currentUserId = null;
        if(onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator">Logged out.</div>';
    }

    function listenForOnlineAdmins() {
        if (onlineUsersListenerUnsubscribe) onlineUsersListenerUnsubscribe();
        if (!currentUserId) { console.warn("No currentUserId for presence listener"); return; }
        const query = db.collection(PRESENCE_COLLECTION);
        onlineUsersListenerUnsubscribe = query.onSnapshot((snapshot) => {
            const now = Date.now(); const activeUsers = [];
            snapshot.forEach(doc => {
                const user = doc.data();
                if (!user || !user.uid || !user.email || !user.lastSeen || typeof user.lastSeen.toDate !== 'function') return;
                try {
                    const lastSeenTime = user.lastSeen.toDate().getTime();
                    if (now - lastSeenTime < PRESENCE_TIMEOUT_MS) activeUsers.push(user);
                } catch (e) { console.error(`Error with lastSeen for ${user.uid}`, e); }
            });
            renderOnlineUsers(activeUsers);
        }, (error) => {
            console.error("Error in presence listener:", error);
            if(onlineUsersContainer) onlineUsersContainer.innerHTML = `<div class="loading-indicator" style="color:red;">Error listening: ${error.message}</div>`;
            if (onlineUsersListenerUnsubscribe) onlineUsersListenerUnsubscribe(); onlineUsersListenerUnsubscribe = null;
        });
    }

    function renderOnlineUsers(users) {
        if (!onlineUsersContainer) return; onlineUsersContainer.innerHTML = '';
        if (users.length === 0) { onlineUsersContainer.innerHTML = '<div class="loading-indicator">No admins active.</div>'; return; }
        users.sort((a, b) => (a.displayName || a.email).localeCompare(b.displayName || b.email));
        users.forEach(user => { /* ... (same rendering logic) ... */
            const indicatorDiv = document.createElement('div'); indicatorDiv.classList.add('user-presence-indicator');
            const circleDiv = document.createElement('div'); circleDiv.classList.add('user-presence-circle', 'live');
            const initial = user.email ? user.email.charAt(0).toUpperCase() : '?'; circleDiv.textContent = initial;
            const nameSpan = document.createElement('span'); nameSpan.classList.add('user-presence-name');
            let name = user.displayName ? user.displayName.split(' ')[0] : user.email.split('@')[0]; name = name.charAt(0).toUpperCase() + name.slice(1); nameSpan.textContent = name; nameSpan.title = user.email;
            indicatorDiv.appendChild(circleDiv); indicatorDiv.appendChild(nameSpan); onlineUsersContainer.appendChild(indicatorDiv);
         });
    }

    // --- General Save Status ---
    function showSaveStatus(message, isError = false) {
        if (!saveStatus) return; saveStatus.textContent = message;
        saveStatus.style.color = isError ? 'red' : 'lightgreen'; saveStatus.style.fontWeight = isError ? 'bold' : 'normal';
        if (window.saveStatusTimeout) clearTimeout(window.saveStatusTimeout);
        window.saveStatusTimeout = setTimeout(() => {
            if (saveStatus.textContent === message) saveStatus.textContent = '';
        }, isError ? 8000 : 5000);
    }

    // --- UI Clearing ---
    function clearAdminUI() {
         if (matchesList) matchesList.innerHTML = ''; if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = ''; if (bracketEditor) bracketEditor.innerHTML = ''; if (saveStatus) saveStatus.textContent = ''; if (addMatchForm) addMatchForm.classList.add('hidden'); if (addPlayerForm) addPlayerForm.classList.add('hidden');
         currentBracketData = { rounds: [] }; currentBracketType = 'pro'; if (bracketSelect) bracketSelect.value = 'pro'; if (onlineUsersContainer) onlineUsersContainer.innerHTML = '';
         if (presenceUpdateInterval) clearInterval(presenceUpdateInterval); presenceUpdateInterval = null; if (onlineUsersListenerUnsubscribe) onlineUsersListenerUnsubscribe(); onlineUsersListenerUnsubscribe = null; currentUserId = null;
         console.log("Admin UI Cleared.");
    }

    // --- Data Loading (Main Admin Sections) ---
    function loadAdminData() {
        loadMatchesAdmin(); loadLeaderboardAdmin();
         if (bracketSelect) { currentBracketType = bracketSelect.value; loadBracketAdmin(currentBracketType); } else { loadBracketAdmin('pro'); }
    }

    // --- Authentication Handling ---
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            console.log("Auth state: Signed in", { uid: user.uid, email: user.email });
            loginError.textContent = ''; authCheckMessage.textContent = '';
            const isAuthorized = await checkAdminAuthorization(user.uid);
            if (isAuthorized) {
                console.log("Admin authorized.");
                loginContainer.classList.add('hidden'); adminPanel.classList.remove('hidden'); adminPanel.classList.add('fade-in');
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;
                await registerPresence(user);
                loadAdminData();
            } else {
                console.log("Admin authorization failed."); userInfo.textContent = ''; adminPanel.classList.add('hidden'); loginContainer.classList.remove('hidden');
            }
        } else {
            console.log("Auth state: Signed out.");
            if (currentUserId) await removePresence(currentUserId);
            adminPanel.classList.add('hidden'); adminPanel.classList.remove('fade-in'); loginContainer.classList.remove('hidden');
            userInfo.textContent = ''; loginError.textContent = ''; authCheckMessage.textContent = ''; clearAdminUI();
        }
    });

    // --- Login/Logout Buttons ---
    loginButton.addEventListener('click', () => {
        loginError.textContent = ''; authCheckMessage.textContent = '';
        auth.signInWithPopup(googleProvider).catch((error) => {
            console.error("Google Sign-in failed:", error); loginError.textContent = `Login failed: ${error.message}`;
        });
    });

    logoutButton.addEventListener('click', async () => {
        console.log("Logout button clicked."); try { await auth.signOut(); } catch (error) { console.error("Sign out error:", error); showSaveStatus(`Logout error: ${error.message}`, true); }
    });

    // =========================================================================
    // --- Matches Management --- (Keep existing functions)
    // =========================================================================
    async function loadMatchesAdmin() { /* ... existing ... */ if (!matchesList) { console.error("loadMatchesAdmin: matchesList element not found"); return; } matchesList.innerHTML = '<div class="loading-indicator">Loading matches...</div>'; console.log("Loading matches from Firestore..."); try { const snapshot = await db.collection('matches').orderBy('date', 'desc').get(); console.log(`Found ${snapshot.size} matches.`); matchesList.innerHTML = ''; if (snapshot.empty) { matchesList.innerHTML = '<p>No matches found.</p>'; return; } snapshot.forEach(doc => { const match = { id: doc.id, ...doc.data() }; const dateForInput = match.date?.toDate ? new Date(match.date.toDate().getTime() - match.date.toDate().getTimezoneOffset() * 60000).toISOString().slice(0, 16) : ''; const matchDiv = document.createElement('div'); matchDiv.classList.add('match-editor'); matchDiv.dataset.id = match.id; matchDiv.innerHTML = ` <h4>Match ID: ${match.id}</h4> <label>Date:</label><input type="datetime-local" value="${dateForInput}" data-field="date"> <label>Type:</label><input type="text" value="${match.type || ''}" data-field="type"> <label>Team 1:</label><input type="text" value="${match.team1?.name || ''}" data-field="team1.name"> <label>Team 1 Logo:</label><input type="text" value="${match.team1?.logo || ''}" data-field="team1.logo" maxlength="2"> <label>Team 2:</label><input type="text" value="${match.team2?.name || ''}" data-field="team2.name"> <label>Team 2 Logo:</label><input type="text" value="${match.team2?.logo || ''}" data-field="team2.logo" maxlength="2"> <label>Venue:</label><input type="text" value="${match.venue || ''}" data-field="venue"> <label>Stream:</label><input type="text" value="${match.streamLink || ''}" data-field="streamLink"> <button class="delete-match-button" data-id="${match.id}">Delete Match</button> `; matchesList.appendChild(matchDiv); }); attachMatchDeleteListeners(); } catch (error) { console.error("Error loading matches:", error); matchesList.innerHTML = '<p style="color:red;">Error loading matches.</p>'; } }
    function attachMatchDeleteListeners() { /* ... existing ... */ document.querySelectorAll('#matches-list .delete-match-button').forEach(button => { const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button); newButton.addEventListener('click', async (e) => { const id = e.target.dataset.id; console.log(`Attempting to delete match ID: ${id}`); if (confirm(`Are you sure you want to delete match ${id}?`)) { try { await db.collection('matches').doc(id).delete(); console.log(`Match ${id} deleted.`); showSaveStatus('Match deleted successfully!', false); loadMatchesAdmin(); } catch (error) { console.error("Error deleting match:", error); showSaveStatus(`Error deleting match: ${error.message}`, true); } } else { console.log("Deletion cancelled."); } }); }); }
    addMatchButton.addEventListener('click', () => { /* ... existing ... */ if (addMatchForm) addMatchForm.classList.toggle('hidden'); });
    saveNewMatchButton.addEventListener('click', async () => { /* ... existing ... */ console.log("Attempting to save NEW match..."); const dateValue = document.getElementById('new-match-date').value; let matchDateTimestamp = null; if (dateValue) { try { matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); } catch (e) { console.error("Invalid date:", e); showSaveStatus('Error: Invalid Date format.', true); return; } } else { showSaveStatus('Error: Match Date & Time is required.', true); return; } const newMatchData = { date: matchDateTimestamp, type: document.getElementById('new-match-type').value.trim(), team1: { name: document.getElementById('new-match-team1-name').value.trim(), logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase() }, team2: { name: document.getElementById('new-match-team2-name').value.trim(), logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase() }, venue: document.getElementById('new-match-venue').value.trim(), streamLink: document.getElementById('new-match-stream').value.trim() }; if (!newMatchData.type || !newMatchData.team1.name || !newMatchData.team2.name) { showSaveStatus('Error: Type, Team 1 Name, and Team 2 Name are required.', true); return; } showSaveStatus('Saving new match...', false); try { const docRef = await db.collection('matches').add(newMatchData); console.log("New match added ID:", docRef.id); showSaveStatus('New match added!', false); addMatchForm.classList.add('hidden'); document.getElementById('new-match-date').value = ''; document.getElementById('new-match-type').value = ''; document.getElementById('new-match-team1-name').value = ''; document.getElementById('new-match-team1-logo').value = ''; document.getElementById('new-match-team2-name').value = ''; document.getElementById('new-match-team2-logo').value = ''; document.getElementById('new-match-venue').value = ''; document.getElementById('new-match-stream').value = 'https://www.twitch.tv/poxelcompetitive/'; loadMatchesAdmin(); } catch (error) { console.error("Error adding match:", error); showSaveStatus(`Error adding match: ${error.message}`, true); } });
    saveMatchesChangesButton.addEventListener('click', async () => { /* ... existing ... */ console.log("Attempting to save ALL match changes..."); const updates = []; let errorsFound = false; document.querySelectorAll('#matches-list .match-editor').forEach(editor => { const id = editor.dataset.id; if (!id) return; const matchData = { team1: {}, team2: {} }; let hasError = false; const dateInput = editor.querySelector('input[data-field="date"]'); if (dateInput) { const dateValue = dateInput.value; if (dateValue) { try { matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); } catch (e) { console.error(`Invalid date format for match ${id}: ${dateValue}`, e); showSaveStatus(`Error: Invalid date for match ${id}. Fix and save again.`, true); hasError = true; errorsFound = true; } } else { console.warn(`Date missing for match ${id}. Setting to null.`); matchData.date = null; } } if (!hasError) { editor.querySelectorAll('input[type="text"], input[type="number"]').forEach(input => { if (input.dataset.field === 'date') return; const fieldPath = input.dataset.field; let value = input.value.trim(); if (input.type === "text" && input.maxLength === 2) { value = value.toUpperCase(); } if (fieldPath?.includes('.')) { const parts = fieldPath.split('.'); if (parts.length === 2) { if (!matchData[parts[0]]) matchData[parts[0]] = {}; matchData[parts[0]][parts[1]] = value; } } else if (fieldPath) { matchData[fieldPath] = value; } }); if (!matchData.type || !matchData.team1?.name || !matchData.team2?.name) { showSaveStatus(`Error: Missing Type or Team Names for match ${id}.`, true); hasError = true; errorsFound = true; } } if (!hasError) { updates.push({ id: id, data: matchData }); } }); if (errorsFound) { showSaveStatus('Errors found. Please fix them before saving all changes.', true); return; } if (updates.length === 0) { showSaveStatus('No changes detected or queued for saving.', false); return; } showSaveStatus(`Saving ${updates.length} match changes...`, false); const batch = db.batch(); updates.forEach(update => { const docRef = db.collection('matches').doc(update.id); batch.update(docRef, update.data); }); try { await batch.commit(); showSaveStatus(`${updates.length} match(es) updated successfully!`, false); loadMatchesAdmin(); } catch (error) { console.error("Error committing match batch update:", error); showSaveStatus(`Error saving match changes: ${error.message}`, true); } });


    // =========================================================================
    // --- Leaderboard Management ---
    // =========================================================================
    async function loadLeaderboardAdmin() { /* ... existing ... */ if (!leaderboardBodyAdmin) return; leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>'; try { const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get(); leaderboardBodyAdmin.innerHTML = ''; let rank = 1; if (snapshot.empty) { leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>'; return; } snapshot.forEach(doc => { const player = { id: doc.id, ...doc.data() }; const row = document.createElement('tr'); row.dataset.id = player.id; const matches = player.matches ?? 0; const wins = player.wins ?? 0; const losses = player.losses ?? 0; const points = player.points ?? 0; row.innerHTML = ` <td>${rank++}</td> <td><input type="text" value="${player.name || ''}" data-field="name" required></td> <td><input type="text" value="${player.avatar || ''}" data-field="avatar" maxlength="2"></td> <td><input type="number" value="${matches}" data-field="matches" min="0"></td> <td><input type="number" value="${wins}" data-field="wins" min="0"></td> <td><input type="number" value="${losses}" data-field="losses" min="0"></td> <td><input type="number" value="${points}" data-field="points"></td> <td><button class="delete-player-button" data-id="${player.id}">Delete</button></td> `; leaderboardBodyAdmin.appendChild(row); }); attachPlayerDeleteListeners(); } catch (error) { console.error("Error loading leaderboard:", error); leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:red;">Error loading leaderboard.</td></tr>'; } }
    function attachPlayerDeleteListeners() { /* ... existing ... */ document.querySelectorAll('#leaderboard-body-admin .delete-player-button').forEach(button => { const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button); newButton.addEventListener('click', async (e) => { const id = e.target.dataset.id; if (!id) return; const row = e.target.closest('tr'); const nameInput = row ? row.querySelector('input[data-field="name"]') : null; const playerName = nameInput ? nameInput.value : `Player ID: ${id}`; if (confirm(`Delete player "${playerName}"?`)) { try { await db.collection('leaderboard').doc(id).delete(); showSaveStatus('Player deleted!', false); loadLeaderboardAdmin(); } catch (error) { console.error(`Error deleting player ${id}:`, error); showSaveStatus(`Error deleting player: ${error.message}`, true); } } }); }); }
    addPlayerButton.addEventListener('click', () => { /* ... existing ... */ if (addPlayerForm) addPlayerForm.classList.toggle('hidden'); });

    // --- >>> REPLACED saveNewPlayerButton Listener (with UID lookup & logging) <<< ---
    saveNewPlayerButton.addEventListener('click', async () => {
        console.log("Attempting to save new player to leaderboard...");
        showSaveStatus('Processing new player...', false);
        saveNewPlayerButton.disabled = true;

        const nameInput = document.getElementById('new-player-name');
        const avatarInput = document.getElementById('new-player-avatar');
        const matchesInput = document.getElementById('new-player-matches');
        const winsInput = document.getElementById('new-player-wins');
        const lossesInput = document.getElementById('new-player-losses');
        const pointsInput = document.getElementById('new-player-points');

        if (!nameInput || !avatarInput || !matchesInput || !winsInput || !lossesInput || !pointsInput) {
            console.error("Save New Player Error: Input element(s) missing.");
            showSaveStatus('Error: Could not find all player form fields.', true);
            saveNewPlayerButton.disabled = false; return;
        }

        const name = nameInput.value.trim();
        const avatar = avatarInput.value.trim().toUpperCase();
        const matches = parseInt(matchesInput.value) || 0;
        const wins = parseInt(winsInput.value) || 0;
        const losses = parseInt(lossesInput.value) || 0;
        const points = parseInt(pointsInput.value) || 0;

        if (!name) { showSaveStatus('Error: Player Name is required.', true); nameInput.focus(); saveNewPlayerButton.disabled = false; return; }
        if (isNaN(matches) || isNaN(wins) || isNaN(losses) || isNaN(points)) { showSaveStatus('Error: Stats must be numbers.', true); saveNewPlayerButton.disabled = false; return; }

        const newPlayerData = { name: name, avatar: avatar, matches: Math.max(0, matches), wins: Math.max(0, wins), losses: Math.max(0, losses), points: points };
        console.log("New player data validated:", newPlayerData);

        // --- Find User UID by Display Name ---
        let targetUID = null;
        try {
            showSaveStatus(`Searching for user '${name}'...`, false);
            const userQuery = db.collection('users').where('displayName', '==', name).limit(2);
            const querySnapshot = await userQuery.get();

            if (querySnapshot.empty) {
                showSaveStatus(`Error: No registered user found with the name "${name}". Player must sign up first.`, true);
                saveNewPlayerButton.disabled = false; return;
            } else if (querySnapshot.size > 1) {
                showSaveStatus(`Error: Multiple users found with the name "${name}". Ensure unique usernames.`, true);
                saveNewPlayerButton.disabled = false; return;
            } else {
                targetUID = querySnapshot.docs[0].id;
                console.log(`Found user UID: ${targetUID}`); // Log UID confirmation
            }
        } catch (error) {
            console.error("Error querying user collection:", error);
            showSaveStatus(`Error searching for user: ${error.message}`, true);
            saveNewPlayerButton.disabled = false; return;
        }

        // --- Save to Leaderboard using the found UID ---
        if (targetUID) {
            try {
                showSaveStatus(`Saving leaderboard data for UID ${targetUID}...`, false);

                // --- >>> ADDED LOGGING <<< ---
                console.log(`>>> FINAL CHECK: Attempting to SET document with ID: ${targetUID}`);
                console.log(`>>> FINAL CHECK: Data being set:`, JSON.stringify(newPlayerData));
                // --- >>> END LOGGING <<< ---

                await db.collection('leaderboard').doc(targetUID).set(newPlayerData); // << THE CORRECT LINE

                console.log(`Leaderboard document set successfully for UID: ${targetUID}`);
                showSaveStatus('New player added to leaderboard successfully!', false);
                addPlayerForm.classList.add('hidden');
                nameInput.value = ''; avatarInput.value = ''; matchesInput.value = '0'; winsInput.value = '0'; lossesInput.value = '0'; pointsInput.value = '0';
                loadLeaderboardAdmin();
            } catch (error) {
                console.error(`Error setting leaderboard document for UID ${targetUID}:`, error);
                showSaveStatus(`Error saving player to leaderboard: ${error.message}`, true);
            } finally {
                 saveNewPlayerButton.disabled = false;
            }
        } else {
            console.error(">>> FAILED to obtain target UID even after checks. Aborting save. Did not call .set()"); // Added log
            showSaveStatus('Error: Could not determine user ID. Save aborted.', true);
            saveNewPlayerButton.disabled = false;
        }
    });
    // --- END REPLACED Listener ---

    saveLeaderboardChangesButton.addEventListener('click', async () => { /* ... existing ... */ console.log("Attempting to save all leaderboard changes..."); const updates = []; let errorsFound = false; document.querySelectorAll('#leaderboard-body-admin tr').forEach(row => { const id = row.dataset.id; if (!id) return; const playerData = {}; let hasRowError = false; row.querySelectorAll('input').forEach(input => { const field = input.dataset.field; if (!field) return; let value = input.value.trim(); if (input.type === 'number') { const parsedValue = parseInt(value); if (isNaN(parsedValue)) { showSaveStatus(`Error: Invalid number for ${field} in row ID ${id}.`, true); hasRowError = true; errorsFound = true; value = 0; } else { value = (field === 'matches' || field === 'wins' || field === 'losses') ? Math.max(0, parsedValue) : parsedValue; } } else if (input.type === 'text') { if (field === 'name' && !value) { showSaveStatus(`Error: Player Name required for ID ${id}.`, true); hasRowError = true; errorsFound = true; } if (field === 'avatar') { value = value.toUpperCase(); } } if (!errorsFound || input.type !== 'number' || !isNaN(parseInt(input.value))) { playerData[field] = value; } }); if (id && !hasRowError) { updates.push({ id: id, data: playerData }); } }); if (errorsFound) { showSaveStatus('Errors found. Please fix them before saving.', true); return; } if (updates.length === 0) { showSaveStatus('No changes detected.', false); return; } showSaveStatus(`Saving ${updates.length} player changes...`, false); const batch = db.batch(); updates.forEach(update => { const docRef = db.collection('leaderboard').doc(update.id); batch.update(docRef, update.data); }); try { await batch.commit(); showSaveStatus(`${updates.length} player(s) updated successfully!`, false); loadLeaderboardAdmin(); } catch (error) { console.error("Error committing leaderboard batch:", error); showSaveStatus(`Error saving leaderboard: ${error.message}`, true); } });

    // =========================================================================
    // --- Bracket Management --- (Keep existing functions)
    // =========================================================================
    async function loadBracketAdmin(bracketType = 'pro') { /* ... existing ... */ if (!bracketEditor || !bracketLoadingIndicator) return; currentBracketType = bracketType; bracketEditor.dataset.type = bracketType; bracketLoadingIndicator.classList.remove('hidden'); bracketLoadingIndicator.textContent = `Loading ${bracketType} bracket...`; bracketEditor.innerHTML = ''; try { const docRef = db.collection('brackets').doc(bracketType); const docSnap = await docRef.get(); if (docSnap.exists) { currentBracketData = docSnap.data(); if (!currentBracketData || typeof currentBracketData !== 'object') currentBracketData = {}; if (!Array.isArray(currentBracketData.rounds)) currentBracketData.rounds = []; currentBracketData.rounds.forEach(round => { if (!round || typeof round !== 'object') round = { name: 'Unnamed Round', matches: [] }; if (!Array.isArray(round.matches)) round.matches = []; round.matches.forEach(match => { if (!match || typeof match !== 'object') match = {}; if (!match.team1 || typeof match.team1 !== 'object') match.team1 = { name: '', score: null }; if (!match.team2 || typeof match.team2 !== 'object') match.team2 = { name: '', score: null }; match.team1.score = (match.team1.score === undefined || match.team1.score === '') ? null : Number(match.team1.score); match.team2.score = (match.team2.score === undefined || match.team2.score === '') ? null : Number(match.team2.score); match.completed = !!match.completed; }); }); } else { currentBracketData = { rounds: [] }; } renderBracketEditor(); } catch (error) { console.error(`ERROR loading ${bracketType} bracket:`, error); bracketEditor.innerHTML = `<p style="color:red;">Error loading ${bracketType} bracket: ${error.message}.</p>`; currentBracketData = { rounds: [] }; } finally { bracketLoadingIndicator.classList.add('hidden'); } }
    function renderBracketEditor() { /* ... existing ... */ if (!bracketEditor) return; bracketEditor.innerHTML = ''; bracketEditor.dataset.type = currentBracketType; const rounds = currentBracketData.rounds || []; if (rounds.length === 0) { const placeholder = document.createElement('p'); placeholder.textContent = 'No rounds yet. Use "Add New Round".'; placeholder.style.padding = '20px'; placeholder.style.textAlign = 'center'; placeholder.style.color = 'var(--text-secondary)'; bracketEditor.appendChild(placeholder); } else { rounds.forEach((round, roundIndex) => { const roundColumnDiv = document.createElement('div'); roundColumnDiv.classList.add('bracket-round-column'); roundColumnDiv.dataset.roundIndex = roundIndex; const roundName = round && typeof round === 'object' && round.name ? round.name : `Round ${roundIndex + 1}`; roundColumnDiv.innerHTML = `<h4><input type="text" value="${roundName}" class="round-name" placeholder="Round Name" data-round-index="${roundIndex}" data-field="name" title="Round Name"><button class="delete-round-button" data-round-index="${roundIndex}" title="Delete Round">X</button></h4><div class="matches-in-round"></div><button class="add-match-to-round-button" data-round-index="${roundIndex}" title="Add Match">Add Match</button>`; const matchesContainer = roundColumnDiv.querySelector('.matches-in-round'); const matches = round && Array.isArray(round.matches) ? round.matches : []; if (matches.length > 0) { matches.forEach((match, matchIndex) => { const matchDiv = renderBracketMatchEditor(match || {}, roundIndex, matchIndex); if (matchDiv && matchesContainer) matchesContainer.appendChild(matchDiv); }); } else { const p = document.createElement('p'); p.textContent = 'No matches yet.'; p.style.textAlign = 'center'; p.style.fontSize = '0.9em'; p.style.color = 'var(--text-secondary)'; matchesContainer.appendChild(p); } bracketEditor.appendChild(roundColumnDiv); }); } attachBracketEditorListeners(); }
    function renderBracketMatchEditor(match, roundIndex, matchIndex) { /* ... existing ... */ const matchDiv = document.createElement('div'); matchDiv.classList.add('bracket-match-editor'); matchDiv.dataset.roundIndex = roundIndex; matchDiv.dataset.matchIndex = matchIndex; const t1N = match?.team1?.name || ''; const t1S = (match?.team1?.score === null || match?.team1?.score === undefined) ? '' : match.team1.score; const t2N = match?.team2?.name || ''; const t2S = (match?.team2?.score === null || match?.team2?.score === undefined) ? '' : match.team2.score; const wN = match?.winnerName || ''; const comp = match?.completed || false; matchDiv.innerHTML = `<h5>Match ${matchIndex + 1}<button class="delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}" title="Delete Match">X</button></h5><label>T1:</label><input type="text" value="${t1N}" data-field="team1.name"><label>S1:</label><input type="number" value="${t1S}" placeholder="-" data-field="team1.score" min="0"><label>T2:</label><input type="text" value="${t2N}" data-field="team2.name"><label>S2:</label><input type="number" value="${t2S}" placeholder="-" data-field="team2.score" min="0"><label>W:</label><input type="text" value="${wN}" placeholder="Win Name" data-field="winnerName"><label class="checkbox-label"><input type="checkbox" ${comp?'checked':''} data-field="completed">Done</label>`; return matchDiv; }
    function attachBracketEditorListeners() { /* ... existing ... */ if (!bracketEditor) return; bracketEditor.removeEventListener('click', handleBracketButtonClick); bracketEditor.addEventListener('click', handleBracketButtonClick); bracketEditor.removeEventListener('input', handleBracketInput); bracketEditor.removeEventListener('change', handleBracketInput); bracketEditor.addEventListener('input', handleBracketInput); bracketEditor.addEventListener('change', handleBracketInput); if (addRoundButton) { addRoundButton.removeEventListener('click', handleAddRoundClick); addRoundButton.addEventListener('click', handleAddRoundClick; } if (saveBracketChangesButton) { saveBracketChangesButton.removeEventListener('click', handleSaveBracketClick); saveBracketChangesButton.addEventListener('click', handleSaveBracketClick); } if (bracketSelect) { bracketSelect.removeEventListener('change', handleBracketSelectChange); bracketSelect.addEventListener('change', handleBracketSelectChange); } }
    function handleBracketSelectChange(e) { /* ... existing ... */ loadBracketAdmin(e.target.value); }
    function handleAddRoundClick() { /* ... existing ... */ if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) currentBracketData = { rounds: [] }; currentBracketData.rounds.push({ name: `Round ${currentBracketData.rounds.length + 1}`, matches: [] }); renderBracketEditor(); }
    async function handleSaveBracketClick() { /* ... existing ... */ if (!currentBracketType || !currentBracketData || !Array.isArray(currentBracketData.rounds)) { showSaveStatus('Error: Bracket data invalid.', true); return; } let dataToSave; try { dataToSave = JSON.parse(JSON.stringify(currentBracketData)); } catch (e) { showSaveStatus('Error: Failed to prep data.', true); return; } let validationError = false; dataToSave.rounds.forEach((round, rIdx) => { if (!round || typeof round !== 'object') { validationError = true; return; } round.name = round.name ? round.name.trim() : `Round ${rIdx + 1}`; if (!Array.isArray(round.matches)) round.matches = []; round.matches.forEach((match, mIdx) => { if (!match || typeof match !== 'object') { validationError = true; return; } if (!match.team1 || typeof match.team1 !== 'object') match.team1 = {}; if (!match.team2 || typeof match.team2 !== 'object') match.team2 = {}; match.team1.name = match.team1.name ? match.team1.name.trim() : ''; match.team2.name = match.team2.name ? match.team2.name.trim() : ''; match.team1.score = (match.team1.score === ''||match.team1.score===null||match.team1.score===undefined)?null:Number(match.team1.score); match.team2.score = (match.team2.score === ''||match.team2.score===null||match.team2.score===undefined)?null:Number(match.team2.score); if ((isNaN(match.team1.score)&&match.team1.score!==null)||(isNaN(match.team2.score)&&match.team2.score!==null)) validationError = true; match.completed=!!match.completed; match.winnerName=match.winnerName?match.winnerName.trim():''; match.winner=null; if(match.completed&&match.winnerName){const wL=match.winnerName.toLowerCase();const t1L=match.team1.name?.toLowerCase();const t2L=match.team2.name?.toLowerCase();if(t1L&&wL===t1L)match.winner=match.team1.name;else if(t2L&&wL===t2L)match.winner=match.team2.name;} }); }); if (validationError) { showSaveStatus('Error: Invalid data in bracket.', true); return; } showSaveStatus(`Saving ${currentBracketType} bracket...`, false); try { await db.collection('brackets').doc(currentBracketType).set(dataToSave); showSaveStatus(`${currentBracketType} bracket saved!`, false); } catch (error) { console.error(`Error saving bracket:`, error); showSaveStatus(`Error saving bracket: ${error.message}`, true); } }
    function handleBracketButtonClick(event) { /* ... existing ... */ const target = event.target; const rIdx = target.dataset.roundIndex; const mIdx = target.dataset.matchIndex; if (target.classList.contains('delete-round-button') && rIdx !== undefined) { deleteBracketRoundFromState(parseInt(rIdx)); } else if (target.classList.contains('add-match-to-round-button') && rIdx !== undefined) { addBracketMatchToState(parseInt(rIdx)); } else if (target.classList.contains('delete-match-from-round-button') && rIdx !== undefined && mIdx !== undefined) { deleteBracketMatchFromState(parseInt(rIdx), parseInt(mIdx)); } }
    function handleBracketInput(event) { /* ... existing ... */ const target = event.target; if (!target || !(target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') || !target.closest('.bracket-round-column')) return; const rIdxS = target.dataset.roundIndex; const mIdxS = target.dataset.matchIndex; const field = target.dataset.field; if (rIdxS === undefined || field === undefined) return; const rIdx = parseInt(rIdxS); const mIdx = (mIdxS !== undefined) ? parseInt(mIdxS) : null; if (isNaN(rIdx) || (mIdxS !== undefined && isNaN(mIdx))) return; try { if (!currentBracketData?.rounds?.[rIdx]) return; const round = currentBracketData.rounds[rIdx]; if (mIdx === null) { if (field === 'name') round.name = target.value.trim(); } else { if (!round.matches?.[mIdx]) return; const match = round.matches[mIdx]; let value = target.type==='checkbox'?target.checked:(target.type==='number'?(target.value===''?null:parseInt(target.value)):target.value); if(target.type==='number'&&isNaN(value)&&target.value!=='')value=null; if (field.includes('.')) { const p=field.split('.'); if(p.length===2){if(!match[p[0]])match[p[0]]={};match[p[0]][p[1]]=value;} } else { match[field] = value; } } } catch (error) { console.error("Error updating state:", error); } }
    function deleteBracketRoundFromState(roundIndex) { /* ... existing ... */ if (!currentBracketData?.rounds?.[roundIndex]) return; const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`; if (confirm(`Delete "${roundName}" and all its matches?`)) { currentBracketData.rounds.splice(roundIndex, 1); renderBracketEditor(); } }
    function addBracketMatchToState(roundIndex) { /* ... existing ... */ if (!currentBracketData?.rounds?.[roundIndex]) return; if (!Array.isArray(currentBracketData.rounds[roundIndex].matches)) currentBracketData.rounds[roundIndex].matches = []; const newMatch = { team1: { name: '', score: null }, team2: { name: '', score: null }, winnerName: '', winner: null, completed: false }; currentBracketData.rounds[roundIndex].matches.push(newMatch); renderBracketEditor(); }
    function deleteBracketMatchFromState(roundIndex, matchIndex) { /* ... existing ... */ if (!currentBracketData?.rounds?.[roundIndex]?.matches?.[matchIndex]) return; const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`; if (confirm(`Delete Match ${matchIndex + 1} from "${roundName}"?`)) { currentBracketData.rounds[roundIndex].matches.splice(matchIndex, 1); renderBracketEditor(); } }


    // =========================================================================
    // --- Initial Load & Event Listeners ---
    // =========================================================================
    console.log("Admin script initialized. Waiting for authentication state...");
    document.addEventListener('DOMContentLoaded', () => { console.log("DOM Content Loaded."); });
    window.addEventListener('beforeunload', () => { if (currentUserId) db.collection(PRESENCE_COLLECTION).doc(currentUserId).delete(); });

    // =========================================================================
    // --- SCRIPT END ---
    // =========================================================================
</script>

</body>
</html>
