<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <style>
        /* ================== Base Styles ================== */
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722; /* Primary orange */
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
            --border-color: #444;
            --green-live: #2ecc71; /* Live indicator / Success */
            --red-error: #e74c3c; /* Errors / General Delete */
            --blue-action: #3498db; /* General actions */
            --input-bg: #333;
            --input-border: #555;
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; margin: 0; }
        h1, h2, h3, h4 { color: var(--orange); margin-top: 0; }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; font-size: 1em; transition: background-color 0.2s ease, opacity 0.2s ease; }
        button:hover { opacity: 0.9; }
        button:active { transform: scale(0.98); }
        button.secondary { background-color: var(--input-border); }
        button.delete { background-color: var(--red-error); } /* Keep for general deletes */
        button.confirm { background-color: var(--green-live); }
        button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7; }

        /* ================== Layout & Containers ================== */
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 25px; border-radius: 8px; margin-bottom: 25px; box-shadow: 0 3px 10px rgba(0,0,0,0.3); }
        .admin-section { margin-top: 25px; border-top: 1px solid var(--border-color); padding-top: 25px; }
        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* ================== Forms & Inputs ================== */
        label { display: block; margin-bottom: 6px; color: var(--text-secondary); font-size: 0.9em; font-weight: 600; }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select {
            width: calc(95% - 20px); /* Adjusted width */
            padding: 10px;
            margin-bottom: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text);
            border-radius: 4px;
            font-size: 1em;
        }
        input[type="checkbox"] { margin-right: 8px; vertical-align: middle; width: auto; }
        textarea { min-height: 70px; resize: vertical; }
        select { width: auto; min-width: 150px; }

        /* ================== Tables ================== */
        table { width: 100%; border-collapse: collapse; margin-top: 15px; table-layout: fixed; /* Helps with column widths */ }
        th, td { border: 1px solid var(--border-color); padding: 10px 12px; text-align: left; font-size: 0.95em; word-wrap: break-word; /* Wrap long text */ }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); font-weight: 600; }
        td input { margin-bottom: 0; padding: 6px; width: calc(100% - 14px); font-size: 0.95em; box-sizing: border-box; } /* Inputs inside tables */
        td button { padding: 5px 10px; font-size: 0.9em; margin: 0 2px; }
        /* Leaderboard column widths */
        #leaderboard-list th:nth-child(1), #leaderboard-list td:nth-child(1) { width: 8%; } /* Rank */
        #leaderboard-list th:nth-child(2), #leaderboard-list td:nth-child(2) { width: 25%; } /* Name */
        #leaderboard-list th:nth-child(3), #leaderboard-list td:nth-child(3) { width: 10%; } /* Avatar */
        #leaderboard-list th:nth-child(4), #leaderboard-list td:nth-child(4) { width: 10%; } /* Matches */
        #leaderboard-list th:nth-child(5), #leaderboard-list td:nth-child(5) { width: 10%; } /* Wins */
        #leaderboard-list th:nth-child(6), #leaderboard-list td:nth-child(6) { width: 10%; } /* Losses */
        #leaderboard-list th:nth-child(7), #leaderboard-list td:nth-child(7) { width: 12%; } /* Points */
        #leaderboard-list th:nth-child(8), #leaderboard-list td:nth-child(8) { width: 15%; } /* Actions */


        /* ================== Specific Sections ================== */
        /* Login */
        #login-error, #auth-check-message { margin-top: 10px; font-weight: bold; min-height: 1.2em; }

        /* Header */
        #admin-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        #user-info { font-size: 0.9em; color: var(--text-secondary); }

        /* Online Users Presence */
        #online-users-section h4 { margin-bottom: 15px; color: var(--text-secondary); font-size: 1em; font-weight: normal; border-bottom: 1px dashed #555; padding-bottom: 10px; }
        #online-users-container { display: flex; flex-wrap: wrap; gap: 25px; min-height: 60px; align-items: center; }
        .user-presence-indicator { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .user-presence-circle { width: 45px; height: 45px; border-radius: 50%; background-color: var(--orange); color: var(--dark); display: flex; align-items: center; justify-content: center; font-size: 1.4em; font-weight: bold; margin-bottom: 6px; border: 3px solid var(--green-live); box-sizing: border-box; text-transform: uppercase; }
        .user-presence-name { font-size: 0.85em; color: var(--text-secondary); max-width: 90px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Add/Edit Forms (Matches, Players) */
        .editor-form {
             margin-bottom: 20px; padding: 20px; border: 1px dashed var(--input-border); border-radius: 5px; background-color: var(--dark);
        }
        .editor-form h4 { margin-bottom: 15px; }

        /* Bracket Editor */
        #bracket-editor { display: flex; overflow-x: auto; padding: 20px 5px 15px 5px; gap: 25px; background-color: var(--dark); border-radius: 5px; border: 1px solid var(--border-color); min-height: 150px; /* Ensure some height */ align-items: flex-start; }
        .bracket-round-column { flex: 0 0 320px; min-width: 280px; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--dark-accent); display: flex; flex-direction: column; gap: 18px; }
        .bracket-round-column h4 { padding-bottom: 10px; border-bottom: 1px dashed var(--input-border); display: flex; justify-content: space-between; align-items: center; }
        .bracket-round-column h4 input[type="text"] { flex-grow: 1; margin-right: 10px; padding: 6px; width: auto; font-size: 1em; }
        .bracket-match-editor { padding: 15px; border: 1px solid var(--input-border); border-radius: 4px; background-color: var(--dark); display: flex; flex-direction: column; gap: 8px; }
        .bracket-match-editor h5 { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 1.05em; color: var(--text); }
        .bracket-round-column h4 button, .bracket-match-editor h5 button { padding: 4px 9px; font-size: 0.85em; margin: 0; } /* Delete buttons */
        .bracket-match-editor label { font-size: 0.9em; margin-bottom: 0; }
        .bracket-match-editor input[type="text"], .bracket-match-editor input[type="number"] { width: calc(100% - 20px); padding: 6px; margin-bottom: 5px; font-size: 0.95em; }
        .bracket-match-editor .checkbox-label { display: flex; align-items: center; margin-top: 5px; font-size: 0.95em; }
        .bracket-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-color); }
        .loading-indicator { font-style: italic; color: var(--text-secondary); padding: 15px; text-align: center; width: 100%; box-sizing: border-box; background-color: rgba(0,0,0,0.1); border-radius: 4px; }
        .loading-indicator.inline { display: inline-block; width: auto; padding: 5px 10px; } /* For smaller indicators */

        /* REMOVED: User Management / Ban Section Styles */
        /* #ban-user-form { ... } */
        /* #ban-status { ... } */
        /* #banned-users-list h4 { ... } */
        /* #banned-users-list table button.unban { ... } */

        /* Save Status */
        #global-save-status { padding: 10px; margin: 15px 0; border-radius: 4px; text-align: center; font-weight: bold; display: none; /* Hidden by default */ }
        #global-save-status.success { background-color: rgba(46, 204, 113, 0.1); color: var(--green-live); }
        #global-save-status.error { background-color: rgba(231, 76, 60, 0.1); color: var(--red-error); }

        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.5em; }
            #admin-panel-header { flex-direction: column; align-items: flex-start; }
            input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select { width: calc(100% - 22px); }
            .bracket-round-column { flex-basis: 90%; min-width: 250px; }
            table { table-layout: auto; } /* Allow table to adjust on smaller screens */
             th, td { font-size: 0.9em; padding: 8px; }
             #leaderboard-list th:nth-child(3), #leaderboard-list td:nth-child(3) { display: none; } /* Hide Avatar */
             #leaderboard-list th:nth-child(4), #leaderboard-list td:nth-child(4), /* Matches */
             #leaderboard-list th:nth-child(5), #leaderboard-list td:nth-child(5), /* Wins */
             #leaderboard-list th:nth-child(6), #leaderboard-list td:nth-child(6) { width: 12%; } /* Losses */
             #leaderboard-list th:nth-child(7), #leaderboard-list td:nth-child(7) { width: 15%; } /* Points */
        }
        @media (max-width: 480px) {
            #leaderboard-list th:nth-child(1), #leaderboard-list td:nth-child(1) { display: none; } /* Hide Rank on small screens */
            /* REMOVED: Responsive styles for Ban table columns */
            /* th:nth-child(3), td:nth-child(3) { width: 35%; } */
            /* th:nth-child(4), td:nth-child(4) { width: 25%; } */
             #leaderboard-list th:nth-child(2), #leaderboard-list td:nth-child(2) { width: 40%; } /* Player Name */
             #leaderboard-list th:nth-child(7), #leaderboard-list td:nth-child(7) { width: 20%; } /* Points */
             #leaderboard-list th:nth-child(4), #leaderboard-list td:nth-child(4), /* Matches */
             #leaderboard-list th:nth-child(5), #leaderboard-list td:nth-child(5), /* Wins */
             #leaderboard-list th:nth-child(6), #leaderboard-list td:nth-child(6) { display: none; } /* Hide detailed stats */

        }

    </style>
</head>
<body>

<h1>Poxel Competitive - Admin</h1>

<!-- Login Section -->
<div id="login-container">
    <h2>Admin Login</h2>
    <p>Please log in with your authorized Google account.</p>
    <button id="login-button">Login with Google</button>
    <p id="login-error" style="color: var(--red-error);"></p>
    <p id="auth-check-message" style="color: orange;"></p>
</div>

<!-- Admin Panel (Initially Hidden) -->
<div id="admin-panel" class="hidden">
    <div id="admin-panel-header">
        <h2>Management Dashboard</h2>
        <div>
            <span id="user-info"></span>
            <button id="logout-button" class="secondary">Logout</button>
        </div>
    </div>

    <!-- Online Users Section -->
    <div id="online-users-section">
        <h4>Online Admins:</h4>
        <div id="online-users-container">
            <div class="loading-indicator">Loading presence...</div>
            <!-- Online users will be rendered here -->
        </div>
    </div>
    <!-- END: Online Users Section -->

    <div id="global-save-status"></div> <!-- Global Save Status Area -->

    <!-- Upcoming Matches Management -->
    <div class="admin-section">
        <h3>Upcoming Matches Management</h3>
        <div id="matches-list"><div class="loading-indicator">Loading matches...</div></div>
        <button id="add-match-button" class="confirm">Add New Match</button>
        <button id="save-matches-changes" style="margin-left: 10px;">Save All Match Changes</button>
        <div id="add-match-form" class="editor-form hidden">
             <h4>New Match Details</h4>
             <label for="new-match-date">Date & Time:</label>
             <input type="datetime-local" id="new-match-date" required>
             <label for="new-match-type">Type (e.g., Quarterfinals):</label>
             <input type="text" id="new-match-type" required>
             <label for="new-match-team1-name">Team 1 Name:</label>
             <input type="text" id="new-match-team1-name" required>
             <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
             <input type="text" id="new-match-team1-logo" maxlength="2">
             <label for="new-match-team2-name">Team 2 Name:</label>
             <input type="text" id="new-match-team2-name" required>
             <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
             <input type="text" id="new-match-team2-logo" maxlength="2">
             <label for="new-match-venue">Venue:</label>
             <input type="text" id="new-match-venue">
             <label for="new-match-stream">Stream Link:</label>
             <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
             <button id="save-new-match" class="confirm">Save New Match</button>
             <button type="button" class="secondary" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
        </div>
    </div>

    <!-- Leaderboard Management -->
    <div class="admin-section">
        <h3>Leaderboard Management</h3>
        <div id="leaderboard-list">
             <table>
                 <thead>
                     <tr>
                         <th>Rank</th><th>Player Name</th><th>Avatar</th><th>Matches</th><th>Wins</th><th>Losses</th><th>Points</th><th>Actions</th>
                     </tr>
                 </thead>
                 <tbody id="leaderboard-body-admin">
                     <tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>
                 </tbody>
             </table>
        </div>
         <button id="add-player-button" class="confirm">Add New Player</button>
         <button id="save-leaderboard-changes" style="margin-left: 10px;">Save Leaderboard Changes</button>
         <div id="add-player-form" class="editor-form hidden">
             <h4>New Player Details</h4>
             <label for="new-player-name">Name:</label><input type="text" id="new-player-name" required>
             <label for="new-player-avatar">Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
             <label for="new-player-matches">Matches:</label><input type="number" id="new-player-matches" value="0" min="0">
             <label for="new-player-wins">Wins:</label><input type="number" id="new-player-wins" value="0" min="0">
             <label for="new-player-losses">Losses:</label><input type="number" id="new-player-losses" value="0" min="0">
             <label for="new-player-points">Points:</label><input type="number" id="new-player-points" value="0">
             <button id="save-new-player" class="confirm">Save New Player</button>
             <button type="button" class="secondary" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
        </div>
    </div>

    <!-- Tournament Bracket Management -->
    <div class="admin-section">
        <h3>Tournament Bracket Management</h3>
        <label for="bracket-select">Select Bracket:</label>
        <select id="bracket-select">
            <option value="pro">Pro Tourney</option>
            <option value="novice">Novice Tourney</option>
            <!-- Add more bracket types as needed -->
        </select>
        <div id="bracket-loading-indicator" class="loading-indicator hidden">Loading...</div>
        <div id="bracket-editor">
             <!-- Bracket content dynamically loaded here -->
        </div>
        <div class="bracket-controls">
             <button id="add-round-button" class="confirm">Add New Round</button>
             <button id="save-bracket-changes">Save Bracket Changes</button>
             <p style="font-size: 0.9em; color: var(--text-secondary); margin-top: 10px;"><i>Note: Bracket rounds are displayed horizontally. Scroll if needed.</i></p>
        </div>
    </div>

    <!-- REMOVED: User Management / Ban Section -->
    <!-- <div class="admin-section user-management-section"> ... </div> -->

</div> <!-- END Admin Panel -->

<!-- Firebase SDK (Compat Version) -->
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore-compat.js"></script>

<script>
    // --- START OF SCRIPT --- //

    const firebaseConfig = {
          apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI", // Replace with your actual config
          authDomain: "poxelcomp.firebaseapp.com",
          projectId: "poxelcomp",
          storageBucket: "poxelcomp.appspot.com", // *** Ensure this is correct ***
          messagingSenderId: "620490990104",
          appId: "1:620490990104:web:709023eb464c7d886b996d",
    };

    // Initialize Firebase (Compat Version)
    if (!firebase.apps.length) {
         firebase.initializeApp(firebaseConfig);
    }
    const auth = firebase.auth();
    const db = firebase.firestore();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // --- DOM Elements ---
    const loginContainer = document.getElementById('login-container');
    const adminPanel = document.getElementById('admin-panel');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userInfo = document.getElementById('user-info');
    const loginError = document.getElementById('login-error');
    const authCheckMessage = document.getElementById('auth-check-message');
    const globalSaveStatus = document.getElementById('global-save-status');
    const onlineUsersContainer = document.getElementById('online-users-container');
    // Matches
    const matchesList = document.getElementById('matches-list');
    const addMatchButton = document.getElementById('add-match-button');
    const addMatchForm = document.getElementById('add-match-form');
    const saveNewMatchButton = document.getElementById('save-new-match');
    const saveMatchesChangesButton = document.getElementById('save-matches-changes');
    // Leaderboard
    const leaderboardList = document.getElementById('leaderboard-list');
    const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
    const addPlayerButton = document.getElementById('add-player-button');
    const addPlayerForm = document.getElementById('add-player-form');
    const saveNewPlayerButton = document.getElementById('save-new-player');
    const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');
    // Bracket
    const bracketSelect = document.getElementById('bracket-select');
    const bracketEditor = document.getElementById('bracket-editor');
    const bracketLoadingIndicator = document.getElementById('bracket-loading-indicator');
    const addRoundButton = document.getElementById('add-round-button');
    const saveBracketChangesButton = document.getElementById('save-bracket-changes');
    // REMOVED: Ban Section Elements
    // const banUserUidInput = document.getElementById('ban-user-uid');
    // const banReasonInput = document.getElementById('ban-reason');
    // const banUserButton = document.getElementById('ban-user-button');
    // const banStatus = document.getElementById('ban-status');
    // const bannedUsersLoading = document.getElementById('banned-users-loading');
    // const bannedUsersTableBody = document.getElementById('banned-users-table-body');
    // const refreshBannedListButton = document.getElementById('refresh-banned-list-button');

    // --- Global State ---
    let currentBracketData = { rounds: [] };
    let currentBracketType = 'pro';
    let currentUserId = null; // UID of the currently logged-in admin
    let presenceUpdateInterval = null;
    let onlineUsersListenerUnsubscribe = null;
    let globalSaveStatusTimeout = null;

    // --- Helper: Escape HTML ---
    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') {
             // Handle non-strings gracefully (e.g., numbers, null, undefined)
             if (unsafe === null || unsafe === undefined) return '';
             try { unsafe = String(unsafe); } catch (e) { return ''; }
        }
        return unsafe
             .replace(/&/g, "&")
             .replace(/</g, "<")
             .replace(/>/g, ">")
             .replace(/"/g, """)
             .replace(/'/g, "'");
    }

    // --- Helper: Show Global Status Message ---
    function showGlobalStatus(message, isError = false) {
        console.log(`Global Status: ${message} (Error: ${isError})`);
        if (!globalSaveStatus) return;
        globalSaveStatus.textContent = message;
        globalSaveStatus.className = isError ? 'error' : 'success'; // Add classes for styling
        globalSaveStatus.style.display = 'block';

        if (globalSaveStatusTimeout) clearTimeout(globalSaveStatusTimeout);
        globalSaveStatusTimeout = setTimeout(() => {
             // Check if the message is still the one we set before clearing
             if (globalSaveStatus.textContent === message) {
                 globalSaveStatus.textContent = '';
                 globalSaveStatus.style.display = 'none';
                 globalSaveStatus.className = ''; // Clear classes
             }
         }, isError ? 8000 : 5000);
     }

    // REMOVED: showBanStatus helper function

    // --- Authorization Check ---
    async function checkAdminAuthorization(uid) {
        console.log(`Checking authorization for UID: ${uid}`);
        authCheckMessage.textContent = 'Checking authorization...';
        authCheckMessage.style.color = 'orange';
        try {
            const adminDoc = await db.collection('admins').doc(uid).get();
            if (adminDoc.exists) {
                console.log(`UID ${uid} IS authorized.`);
                authCheckMessage.textContent = '';
                return true;
            } else {
                console.log(`UID ${uid} is NOT authorized.`);
                authCheckMessage.textContent = 'Access Denied: Your account is not authorized for admin access.';
                authCheckMessage.style.color = 'var(--red-error)';
                return false;
            }
        } catch (error) {
            console.error("Error checking admin authorization:", error);
            authCheckMessage.textContent = `Error checking authorization: ${error.message}`;
            authCheckMessage.style.color = 'var(--red-error)';
            return false;
        }
    }

    // --- Presence Management ---
    const PRESENCE_COLLECTION = 'online_users';
    const PRESENCE_TIMEOUT_MS = 90 * 1000; // 1.5 minutes
    const PRESENCE_UPDATE_INTERVAL_MS = 60 * 1000; // 1 minute

    async function registerPresence(user) {
        if (!user || !user.uid) return;
        currentUserId = user.uid; // Store the current admin's UID
        const presenceRef = db.collection(PRESENCE_COLLECTION).doc(user.uid);
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName || user.email.split('@')[0], // Use display name or part of email
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        };
        try {
            console.log(`Registering presence for ${user.email}`);
            await presenceRef.set(userData, { merge: true }); // Set initial presence

            // Clear any existing interval before starting a new one
            if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);

            // Periodically update the timestamp
            presenceUpdateInterval = setInterval(async () => {
                // Only update if the current user is still logged in
                if (auth.currentUser && auth.currentUser.uid === currentUserId) {
                    try {
                        await presenceRef.update({ lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
                        // console.log(`Presence timestamp updated for ${currentUserId}`);
                    } catch (error) {
                        console.error("Error updating presence timestamp:", error);
                        // If permission denied, likely user deleted/disabled, stop trying
                        if (error.code === 'permission-denied' || error.code === 'unauthenticated') {
                             console.error("Permission denied updating timestamp. Stopping interval.");
                             clearInterval(presenceUpdateInterval); presenceUpdateInterval = null;
                        }
                    }
                } else {
                    // User logged out or changed, stop the interval
                    console.warn("User changed or logged out, stopping presence update interval.");
                    clearInterval(presenceUpdateInterval); presenceUpdateInterval = null;
                }
            }, PRESENCE_UPDATE_INTERVAL_MS);

            // Start listening for other online admins
            listenForOnlineAdmins();

        } catch (error) {
            console.error("Error registering initial presence:", error);
            if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:var(--red-error);">Error setting up presence tracking.</div>';
        }
    }

    async function removePresence(uid) {
        if (!uid) return;
        console.log(`Attempting to remove presence for UID: ${uid}`);

        // Stop the update interval
        if (presenceUpdateInterval) {
            clearInterval(presenceUpdateInterval);
            presenceUpdateInterval = null;
            console.log("Presence update interval stopped.");
        }

        // Detach the listener
        if (onlineUsersListenerUnsubscribe) {
            onlineUsersListenerUnsubscribe();
            onlineUsersListenerUnsubscribe = null;
            console.log("Detached online users listener.");
        }

        // Attempt to delete the presence document
        try {
            await db.collection(PRESENCE_COLLECTION).doc(uid).delete();
            console.log(`Presence document delete requested for ${uid}.`);
        } catch (error) {
            // Log error but continue cleanup
            console.error("Error removing presence document:", error);
        }

        // Clear UI related to presence
        currentUserId = null; // Clear the stored admin UID
        if(onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator">Logged out / Presence inactive.</div>';
    }

    function listenForOnlineAdmins() {
        console.log("Starting listener for online admins...");
        if (onlineUsersListenerUnsubscribe) {
            console.log("Detaching existing online users listener first.");
            onlineUsersListenerUnsubscribe();
        }
        if (!currentUserId) {
            console.warn("Cannot listen for online admins: currentUserId not set.");
            if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:var(--red-error);">Internal error: Cannot track presence.</div>';
            return;
        }

        const query = db.collection(PRESENCE_COLLECTION);

        // Listen for changes in the presence collection
        onlineUsersListenerUnsubscribe = query.onSnapshot((snapshot) => {
            const now = Date.now();
            const activeUsers = [];
            snapshot.forEach(doc => {
                const user = doc.data();
                // Basic validation of presence data
                if (!user || !user.uid || !user.lastSeen?.toDate) {
                    console.warn("Skipping presence doc with missing/invalid data:", doc.id, user);
                    return; // Skip invalid entries
                }
                const lastSeenTime = user.lastSeen.toDate().getTime();
                // Check if the user was seen within the timeout period
                if (now - lastSeenTime < PRESENCE_TIMEOUT_MS) {
                    activeUsers.push(user);
                } else {
                    // Optional: Log inactive users for debugging
                    // console.log(`User ${user.email || user.uid} inactive (last seen: ${new Date(lastSeenTime).toLocaleString()}).`);
                }
            });
            renderOnlineUsers(activeUsers); // Update the UI with active users
        }, (error) => {
            console.error("Error in presence listener:", error);
            if(onlineUsersContainer) onlineUsersContainer.innerHTML = `<div class="loading-indicator" style="color:var(--red-error);">Error listening for presence: ${escapeHtml(error.message)}</div>`;
            // Stop listening on error to prevent loops? Or maybe retry? For now, just stop.
            if (onlineUsersListenerUnsubscribe) {
                onlineUsersListenerUnsubscribe();
                onlineUsersListenerUnsubscribe = null;
            }
        });
        console.log("Online users listener attached.");
    }

    function renderOnlineUsers(users) {
        if (!onlineUsersContainer) return;
        onlineUsersContainer.innerHTML = ''; // Clear current list

        if (!Array.isArray(users) || users.length === 0) {
             onlineUsersContainer.innerHTML = '<div class="loading-indicator">No other admins currently active.</div>';
             return;
        }

        // Sort users alphabetically by display name or email for consistent order
        users.sort((a, b) => (a.displayName || a.email || '').localeCompare(b.displayName || b.email || ''));

        users.forEach(user => {
            const indicatorDiv = document.createElement('div');
            indicatorDiv.classList.add('user-presence-indicator');

            const circleDiv = document.createElement('div');
            circleDiv.classList.add('user-presence-circle');
            // Get first initial from display name or email
            const initial = user.displayName?.[0]?.toUpperCase() || user.email?.[0]?.toUpperCase() || '?';
            circleDiv.textContent = initial;

            const nameSpan = document.createElement('span');
            nameSpan.classList.add('user-presence-name');
            // Display first name or email prefix
            let displayName = user.displayName?.split(' ')[0] || user.email?.split('@')[0] || 'Admin';
            // Capitalize first letter
            nameSpan.textContent = displayName.charAt(0).toUpperCase() + displayName.slice(1);
            nameSpan.title = user.email || 'No email available'; // Tooltip with full email

            indicatorDiv.appendChild(circleDiv);
            indicatorDiv.appendChild(nameSpan);
            onlineUsersContainer.appendChild(indicatorDiv);
        });
    }


    // --- Authentication State Change ---
    auth.onAuthStateChanged(async (user) => {
        // Disable buttons during auth check
        loginButton.disabled = true;
        logoutButton.disabled = true;

        if (user) {
            console.log("Auth state changed: User signed in.", { email: user.email, uid: user.uid });
            loginError.textContent = '';
            authCheckMessage.textContent = ''; // Clear previous messages

            const isAuthorized = await checkAdminAuthorization(user.uid);

            if (isAuthorized) {
                console.log("Authorization successful. Loading admin panel.");
                loginContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                adminPanel.classList.add('fade-in'); // Add animation
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;
                await registerPresence(user); // Register presence AFTER auth success
                loadAdminData(); // Load all admin data sections
                logoutButton.disabled = false; // Enable logout now
            } else {
                console.log("Authorization check failed. Access denied.");
                userInfo.textContent = ''; // Clear user info
                adminPanel.classList.add('hidden'); // Hide admin panel
                loginContainer.classList.remove('hidden'); // Show login section
                // Error message already set by checkAdminAuthorization
                // Optional: Automatically sign out unauthorized users
                // await auth.signOut();
                loginButton.disabled = false; // Re-enable login button
            }
        } else {
            console.log("Auth state changed: User signed out or not logged in.");
            // Ensure presence is removed if an admin was previously logged in
            if (currentUserId) {
                 await removePresence(currentUserId); // Wait for cleanup if possible
            }
            // Reset UI to login state
            adminPanel.classList.add('hidden');
            adminPanel.classList.remove('fade-in');
            loginContainer.classList.remove('hidden');
            userInfo.textContent = '';
            loginError.textContent = ''; // Clear any previous login errors
            authCheckMessage.textContent = ''; // Clear auth messages
            clearAdminUI(); // Clear data displayed in the admin panel
            loginButton.disabled = false; // Enable login button
            logoutButton.disabled = true; // Disable logout button
        }
    });

    // --- Login/Logout Buttons ---
    loginButton.addEventListener('click', () => {
        loginError.textContent = ''; // Clear previous errors
        authCheckMessage.textContent = ''; // Clear messages
        console.log("Attempting Google Sign-in...");
        loginButton.disabled = true; // Disable during login attempt

        auth.signInWithPopup(googleProvider)
            .then((result) => {
                 console.log("Google Sign-in successful:", result.user?.email);
                 // onAuthStateChanged will handle the rest
            })
            .catch((error) => {
                console.error("Google Sign-in failed:", error);
                loginError.textContent = `Login failed: ${error.message}`;
                // Provide more specific messages for common errors
                if (error.code === 'auth/popup-closed-by-user') {
                    loginError.textContent = 'Login cancelled. Please try again.';
                } else if (error.code === 'auth/cancelled-popup-request' || error.code === 'auth/popup-blocked') {
                    loginError.textContent = 'Login popup issue. Please enable popups and try again.';
                }
                authCheckMessage.textContent = ''; // Ensure auth message is clear
                loginButton.disabled = false; // Re-enable button on failure
            });
    });

    logoutButton.addEventListener('click', async () => {
        console.log("Logout button clicked.");
        logoutButton.disabled = true; // Disable during logout
        try {
            // removePresence(currentUserId); // Call remove presence *before* signout if possible
            await auth.signOut();
            console.log("Sign-out successful.");
            // onAuthStateChanged will handle UI reset
        } catch (error) {
            console.error("Error during sign out:", error);
            showGlobalStatus(`Logout error: ${error.message}`, true);
            // Re-enable button if signout fails? Maybe not, state is uncertain.
            // logoutButton.disabled = false;
        }
    });

    // --- UI Clearing ---
    function clearAdminUI() {
         console.log("Clearing Admin UI state...");
         // Clear dynamic content areas
         if (matchesList) matchesList.innerHTML = '';
         if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = '';
         if (bracketEditor) bracketEditor.innerHTML = '';
         // REMOVED: Clear ban table
         // if (bannedUsersTableBody) bannedUsersTableBody.innerHTML = '';

         // Hide forms and reset status messages
         if (globalSaveStatus) { globalSaveStatus.textContent = ''; globalSaveStatus.style.display = 'none'; globalSaveStatus.className = ''; }
         if (addMatchForm) addMatchForm.classList.add('hidden');
         if (addPlayerForm) addPlayerForm.classList.add('hidden');
         // REMOVED: Clear ban form/status
         // if (banUserUidInput) banUserUidInput.value = '';
         // if (banReasonInput) banReasonInput.value = '';
         // if (banStatus) banStatus.textContent = '';
         // if (bannedUsersLoading) bannedUsersLoading.classList.add('hidden');

         // Reset state variables if necessary
         currentBracketData = { rounds: [] };
         currentBracketType = 'pro';
         if (bracketSelect) bracketSelect.value = 'pro'; // Reset dropdown

         // Presence UI cleared by removePresence called in onAuthStateChanged
         console.log("Admin UI Cleared.");
    }

    // --- Data Loading ---
    function loadAdminData() {
         console.log("Loading all admin data sections...");
         showGlobalStatus('Loading admin data...', false); // Show loading status

         // Load data concurrently for better performance
         Promise.all([
             loadMatchesAdmin(),
             loadLeaderboardAdmin(),
             // REMOVED: Load ban list
             // loadBannedUsers(),
             loadBracketAdmin(bracketSelect ? bracketSelect.value : 'pro') // Load initial/selected bracket
         ]).then(() => {
             showGlobalStatus('Admin data loaded.', false); // Indicate loading finished
             attachBracketEditorListeners(); // Ensure bracket listeners are attached after initial load
         }).catch(error => {
             console.error("Error loading one or more admin data sections:", error);
             showGlobalStatus(`Error loading admin data: ${error.message}`, true);
         });
    }

    // --- Matches Management ---
    async function loadMatchesAdmin() {
        if (!matchesList) return Promise.reject("Matches list element not found");
        matchesList.innerHTML = '<div class="loading-indicator">Loading matches...</div>';
        try {
            const snapshot = await db.collection('matches').orderBy('date', 'desc').get();
            matchesList.innerHTML = ''; // Clear loading indicator
            if (snapshot.empty) {
                matchesList.innerHTML = '<p>No upcoming matches found. Use "Add New Match".</p>';
                return Promise.resolve();
            }
            snapshot.forEach(doc => {
                const match = { id: doc.id, ...doc.data() };
                // Format date for datetime-local input (requires YYYY-MM-DDTHH:mm)
                let dateForInput = '';
                if (match.date?.toDate) {
                    try {
                         // Convert Firestore Timestamp to JS Date, adjust for local timezone, format
                         const jsDate = match.date.toDate();
                         // Subtract timezone offset to display correctly in local time input
                         const localDate = new Date(jsDate.getTime() - (jsDate.getTimezoneOffset() * 60000));
                         dateForInput = localDate.toISOString().slice(0, 16);
                    } catch (e) { console.warn("Error formatting date for match:", match.id, e); }
                }

                const matchDiv = document.createElement('div');
                matchDiv.classList.add('editor-form'); // Use common editor style
                matchDiv.dataset.id = match.id;
                matchDiv.style.borderStyle = 'solid'; // Make border solid for existing items
                matchDiv.innerHTML = `
                     <h4>Edit Match (ID: ${escapeHtml(match.id)})</h4>
                     <label>Date & Time (Local):</label><input type="datetime-local" value="${dateForInput}" data-field="date">
                     <label>Type:</label><input type="text" value="${escapeHtml(match.type || '')}" data-field="type" required>
                     <label>Team 1 Name:</label><input type="text" value="${escapeHtml(match.team1?.name || '')}" data-field="team1.name" required>
                     <label>Team 1 Logo:</label><input type="text" value="${escapeHtml(match.team1?.logo || '')}" data-field="team1.logo" maxlength="2">
                     <label>Team 2 Name:</label><input type="text" value="${escapeHtml(match.team2?.name || '')}" data-field="team2.name" required>
                     <label>Team 2 Logo:</label><input type="text" value="${escapeHtml(match.team2?.logo || '')}" data-field="team2.logo" maxlength="2">
                     <label>Venue:</label><input type="text" value="${escapeHtml(match.venue || '')}" data-field="venue">
                     <label>Stream Link:</label><input type="text" value="${escapeHtml(match.streamLink || '')}" data-field="streamLink">
                     <button class="delete delete-match-button" data-id="${match.id}">Delete Match</button>
                 `;
                matchesList.appendChild(matchDiv);
            });
            attachMatchDeleteListeners(); // Re-attach listeners after rendering
            return Promise.resolve();
        } catch (error) {
            console.error("Error loading matches:", error);
            matchesList.innerHTML = '<p style="color:var(--red-error);">Error loading matches data.</p>';
            return Promise.reject(error);
        }
     }
    function attachMatchDeleteListeners() {
         // Use event delegation on the matchesList container for efficiency
         matchesList.removeEventListener('click', handleMatchDeleteClick); // Remove previous listener if any
         matchesList.addEventListener('click', handleMatchDeleteClick);
    }
    async function handleMatchDeleteClick(event) {
        if (!event.target.classList.contains('delete-match-button')) return; // Only handle clicks on delete buttons

        const button = event.target;
        const id = button.dataset.id;
        if (!id) return;

        const matchDiv = button.closest('.editor-form');
        const typeInput = matchDiv?.querySelector('input[data-field="type"]');
        const matchIdentifier = typeInput?.value ? `${typeInput.value} (ID: ${id})` : `Match ID: ${id}`;

        if (confirm(`Are you sure you want to permanently delete match: "${matchIdentifier}"?`)) {
             button.disabled = true; button.textContent = 'Deleting...';
             try {
                 await db.collection('matches').doc(id).delete();
                 showGlobalStatus('Match deleted successfully!', false);
                 matchDiv.remove(); // Remove element directly from DOM
                 // Optional: if list becomes empty, show a message
                 if (!matchesList.querySelector('.editor-form')) {
                    matchesList.innerHTML = '<p>No upcoming matches found.</p>';
                 }
             } catch (error) {
                 showGlobalStatus(`Error deleting match: ${error.message}`, true);
                 button.disabled = false; button.textContent = 'Delete Match';
             }
         }
    }
    addMatchButton.addEventListener('click', () => {
        addMatchForm.classList.toggle('hidden');
        if (!addMatchForm.classList.contains('hidden')) {
            // Optional: Focus the first input when shown
            addMatchForm.querySelector('input')?.focus();
        }
    });
    saveNewMatchButton.addEventListener('click', async () => {
         const dateValue = document.getElementById('new-match-date').value;
         let matchDateTimestamp = null;

         if (dateValue) {
             try {
                 // Convert local datetime-local string to a JS Date, then to Firestore Timestamp
                 matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue));
             } catch (e) {
                 showGlobalStatus('Error: Invalid Date & Time format.', true);
                 return;
             }
         } else {
             showGlobalStatus('Error: Match Date & Time is required.', true);
             return;
         }

         const type = document.getElementById('new-match-type').value.trim();
         const team1Name = document.getElementById('new-match-team1-name').value.trim();
         const team2Name = document.getElementById('new-match-team2-name').value.trim();

         if (!type || !team1Name || !team2Name) {
             showGlobalStatus('Error: Match Type, Team 1 Name, and Team 2 Name are required.', true);
             return;
         }

         const newMatchData = {
             date: matchDateTimestamp,
             type: type,
             team1: {
                 name: team1Name,
                 logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase()
             },
             team2: {
                 name: team2Name,
                 logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase()
             },
             venue: document.getElementById('new-match-venue').value.trim(),
             streamLink: document.getElementById('new-match-stream').value.trim() || 'https://www.twitch.tv/poxelcompetitive/' // Default stream link
         };

         saveNewMatchButton.disabled = true; saveNewMatchButton.textContent = 'Saving...';
         showGlobalStatus('Saving new match...', false);

         try {
             const docRef = await db.collection('matches').add(newMatchData);
             showGlobalStatus(`New match added successfully (ID: ${docRef.id})!`, false);
             addMatchForm.classList.add('hidden'); // Hide form
             // Reset form fields manually
             document.getElementById('new-match-date').value = '';
             document.getElementById('new-match-type').value = '';
             document.getElementById('new-match-team1-name').value = '';
             document.getElementById('new-match-team1-logo').value = '';
             document.getElementById('new-match-team2-name').value = '';
             document.getElementById('new-match-team2-logo').value = '';
             document.getElementById('new-match-venue').value = '';
             document.getElementById('new-match-stream').value = 'https://www.twitch.tv/poxelcompetitive/'; // Reset stream link too
             loadMatchesAdmin(); // Refresh the list to show the new match
         } catch (error) {
             showGlobalStatus(`Error adding match: ${error.message}`, true);
         } finally {
             saveNewMatchButton.disabled = false; saveNewMatchButton.textContent = 'Save New Match';
         }
    });
    saveMatchesChangesButton.addEventListener('click', async () => {
        saveMatchesChangesButton.disabled = true; saveMatchesChangesButton.textContent = 'Validating...';
        const updates = [];
        let errorsFound = false;
        document.querySelectorAll('#matches-list .editor-form[data-id]').forEach(editor => {
            if (errorsFound) return; // Stop processing if an error was already found

            const id = editor.dataset.id;
            if (!id) return;

            const matchData = { team1: {}, team2: {} }; // Initialize nested objects
            let hasEditorError = false;

            const dateInput = editor.querySelector('input[data-field="date"]');
             if (dateInput) {
                 const dateValue = dateInput.value;
                 if (dateValue) {
                     try {
                         matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue));
                     } catch (e) {
                         showGlobalStatus(`Error: Invalid date format for match ID ${id}. Please fix and save again.`, true);
                         hasEditorError = true; errorsFound = true;
                         dateInput.style.borderColor = 'var(--red-error)'; // Highlight error
                     }
                 } else {
                     // Decide how to handle empty date: set to null or error? Assuming null is okay.
                     matchData.date = null;
                     dateInput.style.borderColor = ''; // Clear highlight if previously errored
                 }
             }

             // Process other fields only if date is valid so far
             if (!hasEditorError) {
                 editor.querySelectorAll('input[type="text"], input[type="number"]').forEach(input => {
                      if (input.dataset.field === 'date') return; // Skip date field handled above
                      const fieldPath = input.dataset.field;
                      let value = input.value.trim();

                      // Basic validation for required fields
                      if (input.required && !value) {
                          showGlobalStatus(`Error: Field "${input.previousElementSibling?.textContent || fieldPath}" is required for match ID ${id}.`, true);
                          hasEditorError = true; errorsFound = true;
                          input.style.borderColor = 'var(--red-error)';
                          return; // Stop processing this input
                      } else {
                          input.style.borderColor = ''; // Clear highlight if previously errored
                      }

                      if (input.maxLength === 2) value = value.toUpperCase(); // Assume logo initials

                      // Set value using dot notation for nested fields
                      try {
                          if (fieldPath?.includes('.')) {
                               const parts = fieldPath.split('.');
                               if (parts.length === 2) {
                                   // Ensure parent object exists
                                   if (!matchData[parts[0]]) matchData[parts[0]] = {};
                                   matchData[parts[0]][parts[1]] = value;
                               } else { throw new Error("Invalid field path"); } // Handle deeper nesting if needed
                           } else if (fieldPath) {
                               matchData[fieldPath] = value;
                           }
                       } catch (e) {
                           console.error(`Error processing field ${fieldPath} for match ${id}:`, e);
                           showGlobalStatus(`Internal error processing field ${fieldPath} for match ${id}.`, true);
                           hasEditorError = true; errorsFound = true;
                       }
                 });
             }

             if (!hasEditorError) {
                updates.push({ id: id, data: matchData });
             }
        }); // End forEach editor

         if (errorsFound) {
             showGlobalStatus('Errors found in match data. Please fix the highlighted fields and save again.', true);
             saveMatchesChangesButton.disabled = false; saveMatchesChangesButton.textContent = 'Save All Match Changes';
             return;
         }

         if (updates.length === 0) {
             showGlobalStatus('No changes detected in matches.', false);
             saveMatchesChangesButton.disabled = false; saveMatchesChangesButton.textContent = 'Save All Match Changes';
             return;
         }

         saveMatchesChangesButton.textContent = `Saving ${updates.length} matches...`;
         showGlobalStatus(`Saving ${updates.length} match changes...`, false);

         const batch = db.batch();
         updates.forEach(update => {
             // Ensure we only update, not overwrite completely unless intended
             // Using update() is generally safer than set() with merge if you only want to change specific fields
             batch.update(db.collection('matches').doc(update.id), update.data);
         });

         try {
             await batch.commit();
             showGlobalStatus(`${updates.length} match(es) updated successfully!`, false);
             // Optionally reload to confirm, but changes are reflected
             // loadMatchesAdmin();
         } catch (error) {
             showGlobalStatus(`Error saving match changes: ${error.message}`, true);
         } finally {
              saveMatchesChangesButton.disabled = false; saveMatchesChangesButton.textContent = 'Save All Match Changes';
         }
     });

    // --- Leaderboard Management ---
    async function loadLeaderboardAdmin() {
         if (!leaderboardBodyAdmin) return Promise.reject("Leaderboard body element not found");
         leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>';
         try {
             const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get();
             leaderboardBodyAdmin.innerHTML = ''; // Clear loading/previous data
             let rank = 1;
             if (snapshot.empty) {
                 leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="text-align: center;">No players found in the leaderboard. Use "Add New Player".</td></tr>';
                 return Promise.resolve();
             }
             snapshot.forEach(doc => {
                 const player = { id: doc.id, ...doc.data() };
                 // Provide defaults for potentially missing stats
                 const matches = player.matches ?? 0;
                 const wins = player.wins ?? 0;
                 const losses = player.losses ?? 0;
                 const points = player.points ?? 0;
                 const name = player.name || 'Unnamed Player';
                 const avatar = player.avatar || '';

                 const row = document.createElement('tr');
                 row.dataset.id = player.id; // Store ID for updates/deletes
                 row.innerHTML = `
                      <td>${rank++}</td>
                      <td><input type="text" value="${escapeHtml(name)}" data-field="name" required placeholder="Player Name"></td>
                      <td><input type="text" value="${escapeHtml(avatar)}" data-field="avatar" maxlength="2" placeholder="AB"></td>
                      <td><input type="number" value="${matches}" data-field="matches" min="0"></td>
                      <td><input type="number" value="${wins}" data-field="wins" min="0"></td>
                      <td><input type="number" value="${losses}" data-field="losses" min="0"></td>
                      <td><input type="number" value="${points}" data-field="points"></td>
                       <td><button class="delete delete-player-button" data-id="${player.id}">Delete</button></td>
                  `;
                 leaderboardBodyAdmin.appendChild(row);
             });
             attachPlayerDeleteListeners(); // Attach listeners after rows are created
             return Promise.resolve();
         } catch (error) {
             console.error("Error loading leaderboard:", error);
             leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:var(--red-error); text-align: center;">Error loading leaderboard data.</td></tr>';
             return Promise.reject(error);
         }
     }
    function attachPlayerDeleteListeners() {
         // Use event delegation on the table body
         leaderboardBodyAdmin.removeEventListener('click', handlePlayerDeleteClick); // Remove previous listener
         leaderboardBodyAdmin.addEventListener('click', handlePlayerDeleteClick);
     }
    async function handlePlayerDeleteClick(event) {
         if (!event.target.classList.contains('delete-player-button')) return;

         const button = event.target;
         const id = button.dataset.id;
         if (!id) return;

         const row = button.closest('tr');
         const nameInput = row?.querySelector('input[data-field="name"]');
         const playerName = nameInput ? nameInput.value : `Player ID: ${id}`;

         if (confirm(`Are you sure you want to delete player "${playerName}" (ID: ${id}) from the leaderboard? This cannot be undone.`)) {
             button.disabled = true; button.textContent = 'Deleting...';
             try {
                 await db.collection('leaderboard').doc(id).delete();
                 showGlobalStatus('Player deleted from leaderboard!', false);
                 row.remove(); // Remove row from table
                 // Optional: Re-rank if needed, or just reload
                 // loadLeaderboardAdmin(); // Reload to re-rank
             } catch (error) {
                 showGlobalStatus(`Error deleting player: ${error.message}`, true);
                 button.disabled = false; button.textContent = 'Delete';
             }
         }
     }
    addPlayerButton.addEventListener('click', () => {
         addPlayerForm.classList.toggle('hidden');
         if (!addPlayerForm.classList.contains('hidden')) {
             addPlayerForm.querySelector('input')?.focus();
         }
    });
    saveNewPlayerButton.addEventListener('click', async () => {
         const nameInput = document.getElementById('new-player-name');
         const name = nameInput.value.trim();
         if (!name) {
             showGlobalStatus('Error: Player Name is required.', true);
             nameInput.focus(); return;
         }

         const avatar = document.getElementById('new-player-avatar').value.trim().toUpperCase();
         // Parse stats, defaulting to 0 if input is invalid or empty
         const matches = parseInt(document.getElementById('new-player-matches').value) || 0;
         const wins = parseInt(document.getElementById('new-player-wins').value) || 0;
         const losses = parseInt(document.getElementById('new-player-losses').value) || 0;
         const points = parseInt(document.getElementById('new-player-points').value) || 0;

         // Basic validation for non-negative stats
         if (matches < 0 || wins < 0 || losses < 0) {
             showGlobalStatus('Error: Matches, Wins, and Losses cannot be negative.', true); return;
         }

         const newPlayerData = {
             name: name,
             avatar: avatar,
             matches: matches,
             wins: wins,
             losses: losses,
             points: points
             // Consider adding a 'createdAt' timestamp?
             // createdAt: firebase.firestore.FieldValue.serverTimestamp()
         };

         saveNewPlayerButton.disabled = true; saveNewPlayerButton.textContent = 'Saving...';
         showGlobalStatus('Saving new player...', false);

         try {
             const docRef = await db.collection('leaderboard').add(newPlayerData);
             showGlobalStatus(`New player "${name}" added (ID: ${docRef.id})!`, false);
             addPlayerForm.classList.add('hidden'); // Hide form
             // Reset form
             nameInput.value=''; document.getElementById('new-player-avatar').value='';
             document.getElementById('new-player-matches').value='0'; document.getElementById('new-player-wins').value='0';
             document.getElementById('new-player-losses').value='0'; document.getElementById('new-player-points').value='0';
             loadLeaderboardAdmin(); // Refresh leaderboard
         } catch (error) {
             showGlobalStatus(`Error adding player: ${error.message}`, true);
         } finally {
             saveNewPlayerButton.disabled = false; saveNewPlayerButton.textContent = 'Save New Player';
         }
     });
    saveLeaderboardChangesButton.addEventListener('click', async () => {
        saveLeaderboardChangesButton.disabled = true; saveLeaderboardChangesButton.textContent = 'Validating...';
        const updates = [];
        let errorsFound = false;

        document.querySelectorAll('#leaderboard-body-admin tr[data-id]').forEach(row => {
            if (errorsFound) return; // Stop if error found

            const id = row.dataset.id;
            if (!id) return;

            const playerData = {};
            let hasRowError = false;

            row.querySelectorAll('input').forEach(input => {
                if (hasRowError) return; // Skip remaining inputs for this row if error already found

                const field = input.dataset.field;
                if (!field) return;

                let value = input.value.trim();

                if (input.type === 'number') {
                    const parsedValue = parseInt(value);
                    if (isNaN(parsedValue) || value === '') { // Treat empty number field as error or default to 0? Let's error for now.
                        showGlobalStatus(`Error: Invalid number for ${field} in row ID ${id}.`, true);
                        hasRowError = true; errorsFound = true; input.style.borderColor = 'var(--red-error)';
                    } else {
                        // Ensure non-negative for stats
                        playerData[field] = (field === 'matches' || field === 'wins' || field === 'losses') ? Math.max(0, parsedValue) : parsedValue;
                        input.style.borderColor = ''; // Clear error style
                    }
                } else if (input.type === 'text') {
                    if (field === 'name' && !value) {
                        showGlobalStatus(`Error: Player Name cannot be empty for ID ${id}.`, true);
                        hasRowError = true; errorsFound = true; input.style.borderColor = 'var(--red-error)';
                    } else {
                        playerData[field] = (field === 'avatar') ? value.toUpperCase() : value;
                        input.style.borderColor = ''; // Clear error style
                    }
                }
            }); // End input loop

            if (!hasRowError) {
                updates.push({ id: id, data: playerData });
            }
        }); // End row loop

        if (errorsFound) {
             showGlobalStatus('Errors found in leaderboard data. Please fix highlighted fields and save again.', true);
             saveLeaderboardChangesButton.disabled = false; saveLeaderboardChangesButton.textContent = 'Save Leaderboard Changes';
             return;
        }

        if (updates.length === 0) {
            showGlobalStatus('No changes detected in leaderboard.', false);
            saveLeaderboardChangesButton.disabled = false; saveLeaderboardChangesButton.textContent = 'Save Leaderboard Changes';
            return;
        }

        saveLeaderboardChangesButton.textContent = `Saving ${updates.length} players...`;
        showGlobalStatus(`Saving ${updates.length} player changes...`, false);

        const batch = db.batch();
        updates.forEach(update => {
            batch.update(db.collection('leaderboard').doc(update.id), update.data);
        });

        try {
            await batch.commit();
            showGlobalStatus(`${updates.length} player(s) updated successfully!`, false);
            // Reload to show updated ranks/data
            loadLeaderboardAdmin();
        } catch (error) {
            showGlobalStatus(`Error saving leaderboard changes: ${error.message}`, true);
        } finally {
            saveLeaderboardChangesButton.disabled = false; saveLeaderboardChangesButton.textContent = 'Save Leaderboard Changes';
        }
    });

    // --- Tournament Bracket Management ---
    async function loadBracketAdmin(bracketType = 'pro') {
         if (!bracketEditor || !bracketLoadingIndicator || !bracketSelect) return Promise.reject("Bracket elements not found");
         console.log(`--- Loading bracket: ${bracketType} ---`);

         currentBracketType = bracketType; // Update global state
         bracketEditor.dataset.type = bracketType; // Set data attribute for context
         bracketLoadingIndicator.classList.remove('hidden');
         bracketLoadingIndicator.textContent = `Loading ${escapeHtml(bracketType)} bracket...`;
         bracketEditor.innerHTML = ''; // Clear previous bracket

         try {
             const docRef = db.collection('brackets').doc(bracketType);
             const docSnap = await docRef.get();

             if (docSnap.exists) {
                 currentBracketData = docSnap.data() || { rounds: [] };
                 // Basic validation and cleanup of loaded data
                 if (!Array.isArray(currentBracketData.rounds)) currentBracketData.rounds = [];
                 currentBracketData.rounds.forEach((round, rIdx) => {
                     if (!round || typeof round !== 'object') round = { name: `Round ${rIdx+1}`, matches: [] }; // Default round structure
                     round.name = round.name || `Round ${rIdx+1}`; // Ensure name exists
                     if (!Array.isArray(round.matches)) round.matches = []; // Ensure matches is an array
                     round.matches.forEach((match, mIdx) => {
                         if (!match || typeof match !== 'object') match = {}; // Default match structure
                         // Ensure team objects and their properties exist
                         if (!match.team1 || typeof match.team1 !== 'object') match.team1 = { name: '', score: null };
                         if (!match.team2 || typeof match.team2 !== 'object') match.team2 = { name: '', score: null };
                         match.team1.name = match.team1.name || '';
                         match.team2.name = match.team2.name || '';
                         // Ensure scores are numbers or null
                         match.team1.score = (match.team1.score === '' || match.team1.score === undefined) ? null : Number(match.team1.score);
                         match.team2.score = (match.team2.score === '' || match.team2.score === undefined) ? null : Number(match.team2.score);
                         if (isNaN(match.team1.score)) match.team1.score = null; // Correct NaN scores
                         if (isNaN(match.team2.score)) match.team2.score = null;
                         // Ensure boolean and string fields exist
                         match.completed = !!match.completed;
                         match.winner = match.winner || null; // Winner determined by name usually
                         match.winnerName = match.winnerName || '';
                     });
                 });
             } else {
                 console.log(`Bracket document for "${bracketType}" does not exist. Initializing empty.`);
                 currentBracketData = { rounds: [] }; // Initialize with empty rounds if doc doesn't exist
             }
             renderBracketEditor(); // Render the editor with the cleaned data
             return Promise.resolve();
         } catch (error) {
             console.error(`Error loading ${bracketType} bracket:`, error);
             bracketEditor.innerHTML = `<p style="color:var(--red-error);">Error loading bracket: ${escapeHtml(error.message)}.</p>`;
             currentBracketData = { rounds: [] }; // Reset state on error
             return Promise.reject(error);
         } finally {
             bracketLoadingIndicator.classList.add('hidden'); // Hide loading indicator
         }
     }
    function renderBracketEditor() {
         if (!bracketEditor) return;
         bracketEditor.innerHTML = ''; // Clear previous content
         bracketEditor.dataset.type = currentBracketType; // Ensure type attribute is set

         const rounds = currentBracketData.rounds || [];

         if (rounds.length === 0) {
             bracketEditor.innerHTML = '<p class="loading-indicator" style="width: auto; background: none; color: var(--text-secondary);">No rounds defined for this bracket yet. Use "Add New Round".</p>';
         } else {
             rounds.forEach((round, roundIndex) => {
                 const roundColumnDiv = document.createElement('div');
                 roundColumnDiv.classList.add('bracket-round-column');
                 roundColumnDiv.dataset.roundIndex = roundIndex;

                 const roundName = round?.name || `Round ${roundIndex + 1}`;

                 // Input for round name and delete button for the round
                 const roundHeader = document.createElement('h4');
                 roundHeader.innerHTML = `
                     <input type="text" value="${escapeHtml(roundName)}" class="round-name" placeholder="Round Name" data-round-index="${roundIndex}" data-field="name">
                     <button class="delete delete-round-button" data-round-index="${roundIndex}" title="Delete This Round">X</button>
                 `;

                 const matchesContainer = document.createElement('div');
                 matchesContainer.classList.add('matches-in-round');

                 const matches = round?.matches || [];
                 if (matches.length > 0) {
                     matches.forEach((match, matchIndex) => {
                         matchesContainer.appendChild(renderBracketMatchEditor(match, roundIndex, matchIndex));
                     });
                 } else {
                     matchesContainer.innerHTML = '<p style="text-align: center; font-size: 0.9em; color: var(--text-secondary); margin-top: 10px;">No matches in this round yet.</p>';
                 }

                 const addMatchBtn = document.createElement('button');
                 addMatchBtn.classList.add('confirm', 'add-match-to-round-button');
                 addMatchBtn.dataset.roundIndex = roundIndex;
                 addMatchBtn.title = 'Add a New Match to This Round';
                 addMatchBtn.textContent = 'Add Match';

                 roundColumnDiv.appendChild(roundHeader);
                 roundColumnDiv.appendChild(matchesContainer);
                 roundColumnDiv.appendChild(addMatchBtn);
                 bracketEditor.appendChild(roundColumnDiv);
             });
         }
         // Listeners are attached globally once, managed by attachBracketEditorListeners
     }
    function renderBracketMatchEditor(match, roundIndex, matchIndex) {
        // Creates the HTML structure for a single match editor within a round
        const matchDiv = document.createElement('div');
        matchDiv.classList.add('bracket-match-editor');
        matchDiv.dataset.roundIndex = roundIndex;
        matchDiv.dataset.matchIndex = matchIndex;

        // Safely get values, providing defaults
        const team1Name = match?.team1?.name || '';
        const team1Score = (match?.team1?.score === null || match?.team1?.score === undefined) ? '' : match.team1.score;
        const team2Name = match?.team2?.name || '';
        const team2Score = (match?.team2?.score === null || match?.team2?.score === undefined) ? '' : match.team2.score;
        const winnerName = match?.winnerName || '';
        const completed = match?.completed || false;

        matchDiv.innerHTML = `
            <h5>
                Match ${matchIndex + 1}
                <button class="delete delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}" title="Delete This Match">X</button>
            </h5>
            <label>Team 1 Name:</label>
            <input type="text" value="${escapeHtml(team1Name)}" class="bracket-team-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.name" placeholder="Team 1">

            <label>Team 1 Score:</label>
            <input type="number" value="${team1Score}" class="bracket-team-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.score" min="0">

            <label>Team 2 Name:</label>
            <input type="text" value="${escapeHtml(team2Name)}" class="bracket-team-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.name" placeholder="Team 2">

            <label>Team 2 Score:</label>
            <input type="number" value="${team2Score}" class="bracket-team-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.score" min="0">

            <label>Winner Name (if completed):</label>
            <input type="text" value="${escapeHtml(winnerName)}" class="bracket-winner-name" placeholder="Enter exact winning team name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="winnerName">

            <label class="checkbox-label">
                <input type="checkbox" ${completed ? 'checked' : ''} class="bracket-match-completed" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="completed">
                Match Completed
            </label>
        `;
        return matchDiv;
     }
    function attachBracketEditorListeners() {
        console.log("Attaching bracket editor listeners.");
        if (!bracketEditor) return;

        // Use event delegation on the main bracket editor container
        // Remove previous listeners to prevent duplicates if this function is called multiple times
        bracketEditor.removeEventListener('click', handleBracketButtonClick);
        bracketEditor.removeEventListener('input', handleBracketInputChange);
        bracketEditor.removeEventListener('change', handleBracketInputChange); // For checkboxes

        bracketEditor.addEventListener('click', handleBracketButtonClick);
        bracketEditor.addEventListener('input', handleBracketInputChange); // Catches text/number input changes
        bracketEditor.addEventListener('change', handleBracketInputChange); // Catches checkbox changes

        // Attach listeners for controls outside the main editor div
        if (addRoundButton) {
            addRoundButton.removeEventListener('click', handleAddRoundClick); // Prevent duplicates
            addRoundButton.addEventListener('click', handleAddRoundClick);
        }
        if (saveBracketChangesButton) {
            saveBracketChangesButton.removeEventListener('click', handleSaveBracketClick); // Prevent duplicates
            saveBracketChangesButton.addEventListener('click', handleSaveBracketClick);
        }
        if (bracketSelect) {
             bracketSelect.removeEventListener('change', handleBracketSelectChange); // Prevent duplicates
             bracketSelect.addEventListener('change', handleBracketSelectChange);
        }
    }
    function handleBracketSelectChange(e) {
        // Reload the bracket data when the selection changes
        loadBracketAdmin(e.target.value);
        // Note: loadBracketAdmin calls renderBracketEditor,
        // and attachBracketEditorListeners should be called *after* loadAdminData completes
        // So, no need to re-attach here, it's handled by the main load sequence.
    }
    function handleAddRoundClick() {
        // Adds a new empty round structure to the state and re-renders
        if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) {
            currentBracketData = { rounds: [] }; // Initialize if structure is invalid
        }
        const newRoundIndex = currentBracketData.rounds.length;
        currentBracketData.rounds.push({
             name: `Round ${newRoundIndex + 1}`,
             matches: [] // Start with no matches
        });
        renderBracketEditor(); // Update the UI
        // Optional: scroll to the new round?
        const newRoundElement = bracketEditor.querySelector(`.bracket-round-column[data-round-index="${newRoundIndex}"]`);
        newRoundElement?.scrollIntoView({ behavior: 'smooth', inline: 'end' });
     }
    async function handleSaveBracketClick() {
         saveBracketChangesButton.disabled = true; saveBracketChangesButton.textContent = 'Validating...';

         if (!currentBracketType || !currentBracketData || !Array.isArray(currentBracketData.rounds)) {
             showGlobalStatus('Error: Cannot save. Bracket data is missing or invalid.', true);
             saveBracketChangesButton.disabled = false; saveBracketChangesButton.textContent = 'Save Bracket Changes';
             return;
         }

         // Create a deep copy for validation/saving to avoid modifying state directly during validation
         let dataToSave;
         try {
             dataToSave = JSON.parse(JSON.stringify(currentBracketData));
         } catch (e) {
             showGlobalStatus('Error: Failed to prepare bracket data for saving.', true);
             saveBracketChangesButton.disabled = false; saveBracketChangesButton.textContent = 'Save Bracket Changes';
             return;
         }

         let validationError = false;

         // --- Validate and Clean Data before Saving ---
         dataToSave.rounds.forEach((round, rIdx) => {
             if (validationError) return; // Stop validation if error already found
             if (!round || typeof round !== 'object') { validationError = true; return; } // Basic check

             round.name = (round.name || `Round ${rIdx + 1}`).trim(); // Ensure name, trim whitespace
             if (!round.name) round.name = `Round ${rIdx + 1}`; // Default name if empty after trim

             if (!Array.isArray(round.matches)) round.matches = []; // Ensure matches array

             round.matches.forEach((match, mIdx) => {
                 if (validationError) return;
                 if (!match || typeof match !== 'object') { validationError = true; return; } // Basic check

                 // Ensure team structures
                 if (!match.team1 || typeof match.team1 !== 'object') match.team1 = {};
                 if (!match.team2 || typeof match.team2 !== 'object') match.team2 = {};

                 // Trim names
                 match.team1.name = (match.team1.name || '').trim();
                 match.team2.name = (match.team2.name || '').trim();

                 // Validate and parse scores (null allowed, but not NaN)
                 match.team1.score = (match.team1.score === '' || match.team1.score === undefined || match.team1.score === null) ? null : Number(match.team1.score);
                 match.team2.score = (match.team2.score === '' || match.team2.score === undefined || match.team2.score === null) ? null : Number(match.team2.score);

                 if ((match.team1.score !== null && isNaN(match.team1.score)) || (match.team2.score !== null && isNaN(match.team2.score))) {
                     showGlobalStatus(`Error: Invalid score entered in Round ${rIdx+1}, Match ${mIdx+1}. Scores must be numbers.`, true);
                     validationError = true;
                 }
                 // Ensure boolean and winner name string
                 match.completed = !!match.completed;
                 match.winnerName = (match.winnerName || '').trim();

                 // Determine 'winner' field based on completed status and winnerName matching a team name (case-insensitive)
                 match.winner = null; // Reset winner field
                 if (match.completed && match.winnerName) {
                     const winnerLower = match.winnerName.toLowerCase();
                     const t1Lower = match.team1.name?.toLowerCase();
                     const t2Lower = match.team2.name?.toLowerCase();
                     if (t1Lower && winnerLower === t1Lower) {
                         match.winner = match.team1.name; // Use exact name from input
                     } else if (t2Lower && winnerLower === t2Lower) {
                         match.winner = match.team2.name; // Use exact name from input
                     } else {
                         // Optional: Warn if winner name doesn't match either team?
                         console.warn(`Winner name "${match.winnerName}" in R${rIdx+1} M${mIdx+1} does not match team names "${match.team1.name}" or "${match.team2.name}". 'winner' field will be null.`);
                     }
                 } else if (match.completed && !match.winnerName) {
                      console.warn(`Match R${rIdx+1} M${mIdx+1} marked completed, but no winner name provided.`);
                 }
             });
         });
         // --- End Validation ---

         if (validationError) {
             showGlobalStatus('Validation errors found in bracket data. Please review scores and names, then try saving again.', true);
             saveBracketChangesButton.disabled = false; saveBracketChangesButton.textContent = 'Save Bracket Changes';
             return;
         }

         saveBracketChangesButton.textContent = `Saving ${currentBracketType}...`;
         showGlobalStatus(`Saving ${currentBracketType} bracket changes...`, false);

         try {
             // Use set() to overwrite the entire document with the cleaned data
             await db.collection('brackets').doc(currentBracketType).set(dataToSave);
             showGlobalStatus(`"${currentBracketType}" bracket saved successfully!`, false);
             // Update the local state to match exactly what was saved
             currentBracketData = dataToSave;
         } catch (error) {
             showGlobalStatus(`Error saving bracket: ${error.message}`, true);
             console.error("Error saving bracket to Firestore:", error);
         } finally {
             saveBracketChangesButton.disabled = false; saveBracketChangesButton.textContent = 'Save Bracket Changes';
         }
     }
    function handleBracketButtonClick(event) {
        // Handles clicks on buttons *inside* the bracket editor (delete round, add match, delete match)
        const target = event.target.closest('button'); // Ensure we handle clicks on icons inside buttons too
        if (!target) return; // Click wasn't on a button or its descendant

        const roundIndexStr = target.dataset.roundIndex;
        const matchIndexStr = target.dataset.matchIndex;

        if (target.classList.contains('delete-round-button') && roundIndexStr !== undefined) {
            deleteBracketRoundFromState(parseInt(roundIndexStr));
        } else if (target.classList.contains('add-match-to-round-button') && roundIndexStr !== undefined) {
            addBracketMatchToState(parseInt(roundIndexStr));
        } else if (target.classList.contains('delete-match-from-round-button') && roundIndexStr !== undefined && matchIndexStr !== undefined) {
            deleteBracketMatchFromState(parseInt(roundIndexStr), parseInt(matchIndexStr));
        }
     }
    function handleBracketInputChange(event) {
        // Handles changes in input fields (text, number, checkbox) within the bracket editor
        const target = event.target;
        if (!target || !(target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) return; // Only handle inputs/textareas

        const roundIndexStr = target.dataset.roundIndex;
        const matchIndexStr = target.dataset.matchIndex;
        const field = target.dataset.field;

        // Validate indices and field path
        if (roundIndexStr === undefined || field === undefined) {
             console.warn("Input change ignored: Missing round index or field.", target); return;
        }
        const roundIndex = parseInt(roundIndexStr);
        const matchIndex = (matchIndexStr !== undefined) ? parseInt(matchIndexStr) : null; // Null if it's a round-level field

        if (isNaN(roundIndex) || (matchIndexStr !== undefined && isNaN(matchIndex))) {
             console.warn("Input change ignored: Invalid index.", target); return;
        }

        // --- Update the `currentBracketData` state object ---
        try {
            if (!currentBracketData?.rounds?.[roundIndex]) {
                 console.warn(`Input change ignored: Round ${roundIndex} not found in state.`); return;
            }
            const round = currentBracketData.rounds[roundIndex];

            if (matchIndex === null) {
                // --- Round-level field (e.g., round name) ---
                if (field === 'name') {
                    round.name = target.value; // Update directly (trimming happens on save)
                } else { console.warn("Input change ignored: Unknown round field", field); }
            } else {
                // --- Match-level field ---
                if (!round.matches?.[matchIndex]) {
                     console.warn(`Input change ignored: Match ${matchIndex} in round ${roundIndex} not found.`); return;
                 }
                const match = round.matches[matchIndex];

                // Determine the value based on input type
                let value;
                if (target.type === 'checkbox') {
                    value = target.checked;
                } else if (target.type === 'number') {
                    // Allow empty string for number input, treat as null in state
                    value = (target.value === '') ? null : parseInt(target.value);
                    // If parsing results in NaN (but input wasn't empty), maybe keep it as null? Or original string? Let's use null.
                    if (isNaN(value) && target.value !== '') value = null;
                } else { // Text input
                    value = target.value; // Store raw value, trimming/validation happens on save
                }

                // Update the nested state object using the field path
                if (field.includes('.')) {
                    const parts = field.split('.');
                    if (parts.length === 2) {
                        if (!match[parts[0]]) match[parts[0]] = {}; // Ensure parent object exists (e.g., team1)
                        match[parts[0]][parts[1]] = value;
                    } else { console.warn("Input change ignored: Deeper nesting not handled", field); }
                } else {
                    match[field] = value; // Direct property update (e.g., completed, winnerName)
                }
            }
            // console.log("Bracket state updated:", JSON.stringify(currentBracketData)); // For debugging state changes
        } catch (error) {
            console.error("Error updating bracket state from input:", error, target);
        }
     }
    function deleteBracketRoundFromState(roundIndex) {
         // Removes a round from the local state and re-renders
         if (!currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length) return;
         const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
         if (confirm(`Are you sure you want to delete "${roundName}" and all its matches from the editor? (This is temporary until you save changes)`)) {
             currentBracketData.rounds.splice(roundIndex, 1);
             renderBracketEditor(); // Re-render the UI to reflect the change
         }
     }
    function addBracketMatchToState(roundIndex) {
         // Adds a new empty match structure to a specific round in the state and re-renders
         if (!currentBracketData?.rounds?.[roundIndex]) return;
         if (!Array.isArray(currentBracketData.rounds[roundIndex].matches)) {
             currentBracketData.rounds[roundIndex].matches = []; // Initialize if needed
         }
         const newMatch = {
             team1: { name: '', score: null },
             team2: { name: '', score: null },
             winnerName: '',
             winner: null, // Determined on save based on winnerName
             completed: false
         };
         currentBracketData.rounds[roundIndex].matches.push(newMatch);
         renderBracketEditor(); // Re-render the UI
         // Optional: Focus the first input of the new match?
         const newMatchElement = bracketEditor.querySelector(`.bracket-round-column[data-round-index="${roundIndex}"] .bracket-match-editor:last-child input`);
         newMatchElement?.focus();
    }
    function deleteBracketMatchFromState(roundIndex, matchIndex) {
         // Removes a specific match from a round in the local state and re-renders
         if (!currentBracketData?.rounds?.[roundIndex]?.matches || matchIndex < 0 || matchIndex >= currentBracketData.rounds[roundIndex].matches.length) return;

         const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
         if (confirm(`Are you sure you want to delete Match ${matchIndex + 1} from "${roundName}" in the editor? (Temporary until saved)`)) {
             currentBracketData.rounds[roundIndex].matches.splice(matchIndex, 1);
             renderBracketEditor(); // Re-render the UI
         }
    }

    // REMOVED: All functions related to Ban User Management
    // - banUserButton listener
    // - loadBannedUsers()
    // - attachUnbanListeners()
    // - handleUnbanClick()
    // - refreshBannedListButton listener

    // --- Initial Load Call ---
    console.log("Admin script initialized. Waiting for authentication state...");
    // loadAdminData() is called by the onAuthStateChanged listener upon successful login & authorization

    // --- Window Unload Cleanup ---
    window.addEventListener('beforeunload', (event) => {
        // Attempt a quick, best-effort removal of presence on page close/refresh
        // This might not always succeed, especially on mobile or abrupt closures
        if (currentUserId && auth.currentUser) {
            console.log("beforeunload: Attempting quick presence removal (fire and forget).");
            // Use navigator.sendBeacon if available for higher success rate on unload
            // if (navigator.sendBeacon) {
            //     // Needs a backend endpoint to handle beacon requests to delete Firestore doc
            // } else {
                 // Fire and forget delete - may not complete before page unloads
                 db.collection(PRESENCE_COLLECTION).doc(currentUserId).delete().catch(err => {
                     console.warn("Error during 'beforeunload' presence delete (expected on page close):", err.code);
                 });
            // }
        }
    });

    // --- END OF SCRIPT --- //
</script>

</body>
</html>
