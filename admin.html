
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <style>
        /* ================== Base Styles ================== */
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722; /* Primary orange */
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
            --border-color: #444;
            --green-live: #2ecc71; /* Live indicator / Success */
            --red-error: #e74c3c; /* Errors / Ban */
            --blue-action: #3498db; /* General actions */
            --input-bg: #333;
            --input-border: #555;
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; margin: 0; }
        h1, h2, h3, h4 { color: var(--orange); margin-top: 0; }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; font-size: 1em; transition: opacity 0.2s ease; }
        button:hover { opacity: 0.9; }
        button:active { transform: scale(0.98); }
        button.secondary { background-color: var(--input-border); }
        button.delete, button.ban { background-color: var(--red-error); }
        button.confirm, button.unban { background-color: var(--green-live); }

        /* ================== Layout & Containers ================== */
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 25px; border-radius: 8px; margin-bottom: 25px; box-shadow: 0 3px 10px rgba(0,0,0,0.3); }
        .admin-section { margin-top: 25px; border-top: 1px solid var(--border-color); padding-top: 25px; }
        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* ================== Forms & Inputs ================== */
        label { display: block; margin-bottom: 6px; color: var(--text-secondary); font-size: 0.9em; font-weight: 600; }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select {
            width: calc(95% - 20px); /* Adjusted width */
            padding: 10px;
            margin-bottom: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text);
            border-radius: 4px;
            font-size: 1em;
        }
        input[type="checkbox"] { margin-right: 8px; vertical-align: middle; width: auto; }
        textarea { min-height: 70px; resize: vertical; }
        select { width: auto; min-width: 150px; }

        /* ================== Tables ================== */
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid var(--border-color); padding: 10px 12px; text-align: left; font-size: 0.95em; }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); font-weight: 600; }
        td input { margin-bottom: 0; padding: 6px; width: calc(100% - 14px); font-size: 0.95em; } /* Inputs inside tables */
        td button { padding: 5px 10px; font-size: 0.9em; margin: 0 2px; }

        /* ================== Specific Sections ================== */
        /* Login */
        #login-error, #auth-check-message { margin-top: 10px; font-weight: bold; }

        /* Header */
        #admin-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        #user-info { font-size: 0.9em; color: var(--text-secondary); }

        /* Online Users Presence */
        #online-users-section h4 { margin-bottom: 15px; color: var(--text-secondary); font-size: 1em; font-weight: normal; border-bottom: 1px dashed #555; padding-bottom: 10px; }
        #online-users-container { display: flex; flex-wrap: wrap; gap: 25px; min-height: 60px; align-items: center; }
        .user-presence-indicator { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .user-presence-circle { width: 45px; height: 45px; border-radius: 50%; background-color: var(--orange); color: var(--dark); display: flex; align-items: center; justify-content: center; font-size: 1.4em; font-weight: bold; margin-bottom: 6px; border: 3px solid var(--green-live); box-sizing: border-box; text-transform: uppercase; }
        .user-presence-name { font-size: 0.85em; color: var(--text-secondary); max-width: 90px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Add/Edit Forms (Matches, Players) */
        .editor-form {
             margin-bottom: 20px; padding: 20px; border: 1px dashed var(--input-border); border-radius: 5px; background-color: var(--dark);
        }
        .editor-form h4 { margin-bottom: 15px; }

        /* Bracket Editor */
        #bracket-editor { display: flex; overflow-x: auto; padding: 20px 5px 15px 5px; gap: 25px; background-color: var(--dark); border-radius: 5px; border: 1px solid var(--border-color); }
        .bracket-round-column { flex: 0 0 320px; min-width: 280px; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--dark-accent); display: flex; flex-direction: column; gap: 18px; }
        .bracket-round-column h4 { padding-bottom: 10px; border-bottom: 1px dashed var(--input-border); display: flex; justify-content: space-between; align-items: center; }
        .bracket-round-column h4 input[type="text"] { flex-grow: 1; margin-right: 10px; padding: 6px; width: auto; font-size: 1em; }
        .bracket-match-editor { padding: 15px; border: 1px solid var(--input-border); border-radius: 4px; background-color: var(--dark); display: flex; flex-direction: column; gap: 8px; }
        .bracket-match-editor h5 { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 1.05em; color: var(--text); }
        .bracket-round-column h4 button, .bracket-match-editor h5 button { padding: 4px 9px; font-size: 0.85em; margin: 0; } /* Delete buttons */
        .bracket-match-editor label { font-size: 0.9em; margin-bottom: 0; }
        .bracket-match-editor input[type="text"], .bracket-match-editor input[type="number"] { width: calc(100% - 20px); padding: 6px; margin-bottom: 5px; font-size: 0.95em; }
        .bracket-match-editor .checkbox-label { display: flex; align-items: center; margin-top: 5px; font-size: 0.95em; }
        .bracket-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-color); }
        .loading-indicator { font-style: italic; color: var(--text-secondary); padding: 15px; text-align: center; width: 100%; box-sizing: border-box; background-color: rgba(0,0,0,0.1); border-radius: 4px; }

        /* User Management / Ban Section */
        #ban-user-form { background-color: var(--dark); padding: 20px; border-radius: 5px; border: 1px dashed var(--red-error); margin-top: 10px; max-width: 550px; }
        #ban-user-form h4 { color: var(--red-error); }
        #ban-status { margin-top: 12px; font-weight: bold; min-height: 1.2em; }
        #banned-users-list h4 { margin-top: 30px; border-bottom: 1px dashed var(--border-color); padding-bottom: 8px; }
        #banned-users-list table button.unban { font-size: 0.9em; padding: 4px 8px; }

        /* Save Status */
        #save-status { padding: 10px; margin: 15px 0; border-radius: 4px; text-align: center; font-weight: bold; }
        #save-status.success { background-color: rgba(46, 204, 113, 0.1); color: var(--green-live); }
        #save-status.error { background-color: rgba(231, 76, 60, 0.1); color: var(--red-error); }

        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.5em; }
            #admin-panel-header { flex-direction: column; align-items: flex-start; }
            input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select { width: calc(100% - 22px); }
            .bracket-round-column { flex-basis: 90%; min-width: 250px; }
        }

    </style>
</head>
<body>

<h1>Poxel Competitive - Admin</h1>

<!-- Login Section -->
<div id="login-container">
    <h2>Admin Login</h2>
    <p>Please log in with your authorized Google account.</p>
    <button id="login-button">Login with Google</button>
    <p id="login-error" style="color: var(--red-error);"></p>
    <p id="auth-check-message" style="color: orange;"></p>
</div>

<!-- Admin Panel (Initially Hidden) -->
<div id="admin-panel" class="hidden">
    <div id="admin-panel-header">
        <h2>Management Dashboard</h2>
        <div>
            <span id="user-info"></span>
            <button id="logout-button" class="secondary">Logout</button>
        </div>
    </div>

    <!-- Online Users Section -->
    <div id="online-users-section">
        <h4>Online Admins:</h4>
        <div id="online-users-container">
            <div class="loading-indicator">Loading presence...</div>
            <!-- Online users will be rendered here -->
        </div>
    </div>
    <!-- END: Online Users Section -->

    <div id="save-status"></div> <!-- Global Save Status Area -->

    <!-- Upcoming Matches Management -->
    <div class="admin-section">
        <h3>Upcoming Matches Management</h3>
        <div id="matches-list"><div class="loading-indicator">Loading matches...</div></div>
        <button id="add-match-button" class="confirm">Add New Match</button>
        <button id="save-matches-changes" style="margin-left: 10px;">Save All Match Changes</button>
        <div id="add-match-form" class="editor-form hidden">
             <h4>New Match Details</h4>
             <label for="new-match-date">Date & Time:</label>
             <input type="datetime-local" id="new-match-date" required>
             <label for="new-match-type">Type (e.g., Quarterfinals):</label>
             <input type="text" id="new-match-type" required>
             <label for="new-match-team1-name">Team 1 Name:</label>
             <input type="text" id="new-match-team1-name" required>
             <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
             <input type="text" id="new-match-team1-logo" maxlength="2">
             <label for="new-match-team2-name">Team 2 Name:</label>
             <input type="text" id="new-match-team2-name" required>
             <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
             <input type="text" id="new-match-team2-logo" maxlength="2">
             <label for="new-match-venue">Venue:</label>
             <input type="text" id="new-match-venue">
             <label for="new-match-stream">Stream Link:</label>
             <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
             <button id="save-new-match" class="confirm">Save New Match</button>
             <button type="button" class="secondary" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
        </div>
    </div>

    <!-- Leaderboard Management -->
    <div class="admin-section">
        <h3>Leaderboard Management</h3>
        <div id="leaderboard-list">
             <table>
                 <thead>
                     <tr>
                         <th>Rank</th><th>Player Name</th><th>Avatar</th><th>Matches</th><th>Wins</th><th>Losses</th><th>Points</th><th>Actions</th>
                     </tr>
                 </thead>
                 <tbody id="leaderboard-body-admin">
                     <tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>
                 </tbody>
             </table>
        </div>
         <button id="add-player-button" class="confirm">Add New Player</button>
         <button id="save-leaderboard-changes" style="margin-left: 10px;">Save Leaderboard Changes</button>
         <div id="add-player-form" class="editor-form hidden">
             <h4>New Player Details</h4>
             <label for="new-player-name">Name:</label><input type="text" id="new-player-name" required>
             <label for="new-player-avatar">Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
             <label for="new-player-matches">Matches:</label><input type="number" id="new-player-matches" value="0" min="0">
             <label for="new-player-wins">Wins:</label><input type="number" id="new-player-wins" value="0" min="0">
             <label for="new-player-losses">Losses:</label><input type="number" id="new-player-losses" value="0" min="0">
             <label for="new-player-points">Points:</label><input type="number" id="new-player-points" value="0">
             <button id="save-new-player" class="confirm">Save New Player</button>
             <button type="button" class="secondary" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
        </div>
    </div>

    <!-- Tournament Bracket Management -->
    <div class="admin-section">
        <h3>Tournament Bracket Management</h3>
        <label for="bracket-select">Select Bracket:</label>
        <select id="bracket-select">
            <option value="pro">Pro Tourney</option>
            <option value="novice">Novice Tourney</option>
            <!-- Add more bracket types as needed -->
        </select>
        <div id="bracket-loading-indicator" class="loading-indicator hidden">Loading...</div>
        <div id="bracket-editor"></div>
        <div class="bracket-controls">
             <button id="add-round-button" class="confirm">Add New Round</button>
             <button id="save-bracket-changes">Save Bracket Changes</button>
             <p style="font-size: 0.9em; color: var(--text-secondary); margin-top: 10px;"><i>Note: Bracket rounds are displayed horizontally. Scroll if needed.</i></p>
        </div>
    </div>

    <!-- User Management / Ban Section -->
    <div class="admin-section user-management-section">
        <h3>User Management</h3>

        <div id="ban-user-form">
            <h4>Ban User</h4>
            <label for="ban-user-uid">User UID to Ban:</label>
            <input type="text" id="ban-user-uid" placeholder="Enter the Firebase User ID" required>

            <label for="ban-reason">Ban Reason:</label>
            <textarea id="ban-reason" placeholder="Enter reason for banning (required)" required></textarea>

            <button id="ban-user-button" class="ban">Ban User</button>
            <p id="ban-status"></p> <!-- Status message specific to ban -->
        </div>

        <div id="banned-users-list">
            <h4>Currently Banned Users</h4>
            <button id="refresh-banned-list-button" class="secondary" style="float: right; margin-top: -45px;">Refresh List</button>
             <div id="banned-users-loading" class="loading-indicator">Loading banned users...</div>
            <table>
                <thead>
                    <tr>
                        <th>UID</th>
                        <th>Reason</th>
                        <th>Banned At</th>
                        <th>Banned By</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="banned-users-table-body">
                    <!-- Banned users will be listed here -->
                </tbody>
            </table>
        </div>
    </div> <!-- END User Management Section -->

</div> <!-- END Admin Panel -->

<!-- Firebase SDK -->
<!-- Use the compat version as specified in profile.js -->
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore-compat.js"></script>

<script>
    // --- START OF SCRIPT --- //

    const firebaseConfig = {
          apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI", // Replace with your actual config if different
          authDomain: "poxelcomp.firebaseapp.com",
          projectId: "poxelcomp",
          storageBucket: "poxelcomp.firebasestorage.app", // CHECK IF CORRECT BUCKET NAME
          messagingSenderId: "620490990104",
          appId: "1:620490990104:web:709023eb464c7d886b996d",
    };

    // Initialize Firebase (Compat Version)
    if (!firebase.apps.length) {
         firebase.initializeApp(firebaseConfig);
    }
    const auth = firebase.auth();
    const db = firebase.firestore();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // --- DOM Elements ---
    const loginContainer = document.getElementById('login-container');
    const adminPanel = document.getElementById('admin-panel');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userInfo = document.getElementById('user-info');
    const loginError = document.getElementById('login-error');
    const authCheckMessage = document.getElementById('auth-check-message');
    const globalSaveStatus = document.getElementById('save-status'); // Renamed for clarity
    const onlineUsersContainer = document.getElementById('online-users-container');
    const matchesList = document.getElementById('matches-list');
    const addMatchButton = document.getElementById('add-match-button');
    const addMatchForm = document.getElementById('add-match-form');
    const saveNewMatchButton = document.getElementById('save-new-match');
    const saveMatchesChangesButton = document.getElementById('save-matches-changes');
    const leaderboardList = document.getElementById('leaderboard-list');
    const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
    const addPlayerButton = document.getElementById('add-player-button');
    const addPlayerForm = document.getElementById('add-player-form');
    const saveNewPlayerButton = document.getElementById('save-new-player');
    const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');
    const bracketSelect = document.getElementById('bracket-select');
    const bracketEditor = document.getElementById('bracket-editor');
    const bracketLoadingIndicator = document.getElementById('bracket-loading-indicator');
    const addRoundButton = document.getElementById('add-round-button');
    const saveBracketChangesButton = document.getElementById('save-bracket-changes');
    // Ban Section Elements
    const banUserUidInput = document.getElementById('ban-user-uid');
    const banReasonInput = document.getElementById('ban-reason');
    const banUserButton = document.getElementById('ban-user-button');
    const banStatus = document.getElementById('ban-status');
    const bannedUsersLoading = document.getElementById('banned-users-loading');
    const bannedUsersTableBody = document.getElementById('banned-users-table-body');
    const refreshBannedListButton = document.getElementById('refresh-banned-list-button');

    // --- Global State ---
    let currentBracketData = { rounds: [] };
    let currentBracketType = 'pro';
    let currentUserId = null;
    let presenceUpdateInterval = null;
    let onlineUsersListenerUnsubscribe = null;
    let globalSaveStatusTimeout = null; // For the global status message

    // --- Helper: Escape HTML ---
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        try {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        } catch(e) {
            console.warn("Error escaping HTML for:", unsafe, e);
            return "Error"; // Return something safe
        }
    }

    // --- Helper: Show Global Status Message ---
    function showGlobalStatus(message, isError = false) {
        console.log(`Global Status: ${message} (Error: ${isError})`);
        if (!globalSaveStatus) return;
        globalSaveStatus.textContent = message;
        globalSaveStatus.className = isError ? 'error' : 'success'; // Add classes for styling
        globalSaveStatus.style.display = 'block';

        if (globalSaveStatusTimeout) clearTimeout(globalSaveStatusTimeout);
        globalSaveStatusTimeout = setTimeout(() => {
             if (globalSaveStatus.textContent === message) {
                 globalSaveStatus.textContent = '';
                 globalSaveStatus.style.display = 'none';
                 globalSaveStatus.className = ''; // Clear classes
             }
         }, isError ? 8000 : 5000);
     }

    // --- Authorization Check ---
    async function checkAdminAuthorization(uid) {
        console.log(`Checking authorization for UID: ${uid}`);
        authCheckMessage.textContent = 'Checking authorization...';
        authCheckMessage.style.color = 'orange';
        try {
            const adminDoc = await db.collection('admins').doc(uid).get();
            if (adminDoc.exists) {
                console.log(`UID ${uid} IS authorized.`);
                authCheckMessage.textContent = '';
                return true;
            } else {
                console.log(`UID ${uid} is NOT authorized.`);
                authCheckMessage.textContent = 'Access Denied: Your account is not authorized.';
                authCheckMessage.style.color = 'var(--red-error)';
                return false;
            }
        } catch (error) {
            console.error("Error checking admin authorization:", error);
            authCheckMessage.textContent = `Error checking authorization: ${error.message}`;
            authCheckMessage.style.color = 'var(--red-error)';
            return false;
        }
    }

    // --- Presence Management ---
    const PRESENCE_COLLECTION = 'online_users';
    const PRESENCE_TIMEOUT_MS = 90 * 1000;
    const PRESENCE_UPDATE_INTERVAL_MS = 60 * 1000;

    async function registerPresence(user) {
        if (!user || !user.uid) return;
        currentUserId = user.uid;
        const presenceRef = db.collection(PRESENCE_COLLECTION).doc(user.uid);
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName || user.email.split('@')[0],
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        };
        try {
            console.log(`Registering presence for ${user.email}`);
            await presenceRef.set(userData, { merge: true });
            if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
            presenceUpdateInterval = setInterval(async () => {
                if (auth.currentUser && auth.currentUser.uid === currentUserId) {
                    try {
                        await presenceRef.update({ lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
                    } catch (error) {
                        console.error("Error updating presence timestamp:", error);
                        if (error.code === 'permission-denied') {
                             console.error("Permission denied updating timestamp. Stopping interval.");
                             clearInterval(presenceUpdateInterval); presenceUpdateInterval = null;
                        }
                    }
                } else {
                    console.warn("User changed/logged out, stopping presence interval.");
                    clearInterval(presenceUpdateInterval); presenceUpdateInterval = null;
                }
            }, PRESENCE_UPDATE_INTERVAL_MS);
            listenForOnlineAdmins();
        } catch (error) {
            console.error("Error registering initial presence:", error);
            if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:var(--red-error);">Error setting up presence.</div>';
        }
    }

    async function removePresence(uid) {
        if (!uid) return;
        console.log(`Removing presence for UID: ${uid}`);
        if (presenceUpdateInterval) { clearInterval(presenceUpdateInterval); presenceUpdateInterval = null; }
        if (onlineUsersListenerUnsubscribe) { onlineUsersListenerUnsubscribe(); onlineUsersListenerUnsubscribe = null; console.log("Detached online users listener."); }
        try {
            await db.collection(PRESENCE_COLLECTION).doc(uid).delete(); // Wait for delete before clearing UI
            console.log(`Presence document delete request completed for ${uid}`);
        } catch (error) { console.error("Error removing presence document:", error); }
        currentUserId = null;
        if(onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator">Logged out.</div>';
    }

    function listenForOnlineAdmins() {
        console.log("Starting listener for online admins...");
        if (onlineUsersListenerUnsubscribe) { console.log("Detaching existing listener."); onlineUsersListenerUnsubscribe(); }
        if (!currentUserId) { console.warn("listenForOnlineAdmins called before currentUserId set."); return; }

        const query = db.collection(PRESENCE_COLLECTION);
        onlineUsersListenerUnsubscribe = query.onSnapshot((snapshot) => {
            const now = Date.now();
            const activeUsers = [];
            snapshot.forEach(doc => {
                const user = doc.data();
                if (!user || !user.uid || !user.email || !user.lastSeen?.toDate) {
                    console.warn("Skipping presence doc with missing/invalid data:", doc.id, user); return;
                }
                const lastSeenTime = user.lastSeen.toDate().getTime();
                if (now - lastSeenTime < PRESENCE_TIMEOUT_MS) {
                    activeUsers.push(user);
                } else { /* console.log(`User ${user.email} inactive.`); */ }
            });
            renderOnlineUsers(activeUsers);
        }, (error) => {
            console.error("Error in presence listener:", error);
            if(onlineUsersContainer) onlineUsersContainer.innerHTML = `<div class="loading-indicator" style="color:var(--red-error);">Error listening for presence: ${error.message}</div>`;
            if (onlineUsersListenerUnsubscribe) { onlineUsersListenerUnsubscribe(); onlineUsersListenerUnsubscribe = null; }
        });
        console.log("Presence listener attached.");
    }

    function renderOnlineUsers(users) {
        if (!onlineUsersContainer) return;
        onlineUsersContainer.innerHTML = '';
        if (users.length === 0) {
             onlineUsersContainer.innerHTML = '<div class="loading-indicator">No admins currently active.</div>'; return;
        }
        users.sort((a, b) => (a.displayName || a.email).localeCompare(b.displayName || b.email));
        users.forEach(user => {
            const indicatorDiv = document.createElement('div'); indicatorDiv.classList.add('user-presence-indicator');
            const circleDiv = document.createElement('div'); circleDiv.classList.add('user-presence-circle');
            circleDiv.textContent = user.displayName?.[0]?.toUpperCase() || user.email[0]?.toUpperCase() || '?';
            const nameSpan = document.createElement('span'); nameSpan.classList.add('user-presence-name');
            let name = user.displayName?.split(' ')[0] || user.email.split('@')[0];
            nameSpan.textContent = name.charAt(0).toUpperCase() + name.slice(1);
            nameSpan.title = user.email;
            indicatorDiv.appendChild(circleDiv); indicatorDiv.appendChild(nameSpan);
            onlineUsersContainer.appendChild(indicatorDiv);
        });
    }

    // --- Authentication State Change ---
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            console.log("Auth state changed: User signed in.", { email: user.email, uid: user.uid });
            loginError.textContent = ''; authCheckMessage.textContent = '';
            const isAuthorized = await checkAdminAuthorization(user.uid);
            if (isAuthorized) {
                console.log("Authorization successful. Loading admin panel & presence.");
                loginContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                adminPanel.classList.add('fade-in');
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;
                await registerPresence(user); // Register presence AFTER auth success
                loadAdminData(); // Load all admin sections
            } else {
                console.log("Authorization check failed.");
                userInfo.textContent = ''; adminPanel.classList.add('hidden'); loginContainer.classList.remove('hidden');
                // Optional: Sign out user if not authorized
                // await auth.signOut();
            }
        } else {
            console.log("Auth state changed: User signed out.");
            if (currentUserId) await removePresence(currentUserId); // Ensure presence is removed before clearing UI
            adminPanel.classList.add('hidden'); adminPanel.classList.remove('fade-in');
            loginContainer.classList.remove('hidden');
            userInfo.textContent = ''; loginError.textContent = ''; authCheckMessage.textContent = '';
            clearAdminUI();
        }
    });

    // --- Login/Logout Buttons ---
    loginButton.addEventListener('click', () => {
        loginError.textContent = ''; authCheckMessage.textContent = '';
        console.log("Attempting Google Sign-in...");
        auth.signInWithPopup(googleProvider).catch((error) => {
                console.error("Google Sign-in failed:", error);
                loginError.textContent = `Login failed: ${error.message}`;
                if (error.code === 'auth/popup-closed-by-user') loginError.textContent = 'Login cancelled.';
                else if (error.code === 'auth/cancelled-popup-request') loginError.textContent = 'Login popup issue. Please try again.';
                else if (error.code === 'auth/popup-blocked') loginError.textContent = 'Login popup blocked. Please allow popups.';
                authCheckMessage.textContent = '';
            });
    });

    logoutButton.addEventListener('click', async () => {
        console.log("Logout button clicked.");
        try { await auth.signOut(); console.log("Sign-out successful."); }
        catch (error) { console.error("Error during sign out:", error); showGlobalStatus(`Logout error: ${error.message}`, true); }
    });

    // --- UI Clearing ---
    function clearAdminUI() {
         console.log("Clearing Admin UI state...");
        if (matchesList) matchesList.innerHTML = '';
        if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = '';
        if (bracketEditor) bracketEditor.innerHTML = '';
        if (globalSaveStatus) { globalSaveStatus.textContent = ''; globalSaveStatus.style.display = 'none'; globalSaveStatus.className = ''; }
        if (addMatchForm) addMatchForm.classList.add('hidden');
        if (addPlayerForm) addPlayerForm.classList.add('hidden');
        if (banUserUidInput) banUserUidInput.value = '';
        if (banReasonInput) banReasonInput.value = '';
        if (banStatus) banStatus.textContent = '';
        if (bannedUsersTableBody) bannedUsersTableBody.innerHTML = '';
        if (bannedUsersLoading) bannedUsersLoading.classList.add('hidden');
        currentBracketData = { rounds: [] };
        currentBracketType = 'pro';
        if (bracketSelect) bracketSelect.value = 'pro';
        if (onlineUsersContainer) onlineUsersContainer.innerHTML = '';
         // Presence cleanup handled by auth listener calling removePresence
        console.log("Admin UI Cleared.");
    }

    // --- Data Loading ---
    function loadAdminData() {
         console.log("Loading all admin data sections...");
        loadMatchesAdmin();
        loadLeaderboardAdmin();
        loadBannedUsers(); // Load ban list
        if (bracketSelect) {
            currentBracketType = bracketSelect.value;
            loadBracketAdmin(currentBracketType);
         } else { loadBracketAdmin('pro'); }
         attachBracketEditorListeners(); // Ensure bracket listeners are attached after initial load
    }

    // --- Matches Management ---
    async function loadMatchesAdmin() {
        if (!matchesList) return;
        matchesList.innerHTML = '<div class="loading-indicator">Loading matches...</div>';
        try {
            const snapshot = await db.collection('matches').orderBy('date', 'desc').get();
            matchesList.innerHTML = '';
            if (snapshot.empty) { matchesList.innerHTML = '<p>No matches found.</p>'; return; }
            snapshot.forEach(doc => {
                const match = { id: doc.id, ...doc.data() };
                const dateForInput = match.date?.toDate ? new Date(match.date.toDate().getTime() - match.date.toDate().getTimezoneOffset() * 60000).toISOString().slice(0, 16) : '';
                const matchDiv = document.createElement('div');
                matchDiv.classList.add('editor-form'); // Use common editor style
                matchDiv.dataset.id = match.id;
                matchDiv.style.borderStyle = 'solid'; // Make border solid for existing items
                matchDiv.innerHTML = `
                     <h4>Edit Match (ID: ${match.id})</h4>
                     <label>Date:</label><input type="datetime-local" value="${dateForInput}" data-field="date">
                     <label>Type:</label><input type="text" value="${escapeHtml(match.type || '')}" data-field="type">
                     <label>Team 1 Name:</label><input type="text" value="${escapeHtml(match.team1?.name || '')}" data-field="team1.name">
                     <label>Team 1 Logo:</label><input type="text" value="${escapeHtml(match.team1?.logo || '')}" data-field="team1.logo" maxlength="2">
                     <label>Team 2 Name:</label><input type="text" value="${escapeHtml(match.team2?.name || '')}" data-field="team2.name">
                     <label>Team 2 Logo:</label><input type="text" value="${escapeHtml(match.team2?.logo || '')}" data-field="team2.logo" maxlength="2">
                     <label>Venue:</label><input type="text" value="${escapeHtml(match.venue || '')}" data-field="venue">
                     <label>Stream:</label><input type="text" value="${escapeHtml(match.streamLink || '')}" data-field="streamLink">
                     <button class="delete delete-match-button" data-id="${match.id}">Delete Match</button>
                 `;
                matchesList.appendChild(matchDiv);
            });
            attachMatchDeleteListeners();
        } catch (error) {
            console.error("Error loading matches:", error);
            matchesList.innerHTML = '<p style="color:var(--red-error);">Error loading matches.</p>';
        }
     }
    function attachMatchDeleteListeners() {
        document.querySelectorAll('#matches-list .delete-match-button').forEach(button => {
             const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button);
             newButton.addEventListener('click', async (e) => {
                 const id = e.target.dataset.id;
                 if (confirm(`Are you sure you want to delete match ${id}?`)) {
                     try {
                         await db.collection('matches').doc(id).delete();
                         showGlobalStatus('Match deleted successfully!', false); loadMatchesAdmin();
                     } catch (error) { showGlobalStatus(`Error deleting match: ${error.message}`, true); }
                 }
             });
         });
    }
    addMatchButton.addEventListener('click', () => { addMatchForm.classList.toggle('hidden'); });
    saveNewMatchButton.addEventListener('click', async () => {
         const dateValue = document.getElementById('new-match-date').value;
         let matchDateTimestamp = null;
         if (dateValue) { try { matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); } catch (e) { showGlobalStatus('Error: Invalid Date format.', true); return; } }
         else { showGlobalStatus('Error: Match Date & Time is required.', true); return; }
         const newMatchData = {
             date: matchDateTimestamp,
             type: document.getElementById('new-match-type').value.trim(),
             team1: { name: document.getElementById('new-match-team1-name').value.trim(), logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase() },
             team2: { name: document.getElementById('new-match-team2-name').value.trim(), logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase() },
             venue: document.getElementById('new-match-venue').value.trim(),
             streamLink: document.getElementById('new-match-stream').value.trim()
         };
         if (!newMatchData.type || !newMatchData.team1.name || !newMatchData.team2.name) { showGlobalStatus('Error: Type, Team 1 Name, and Team 2 Name are required.', true); return; }
         showGlobalStatus('Saving new match...', false);
         try {
             await db.collection('matches').add(newMatchData);
             showGlobalStatus('New match added!', false); addMatchForm.classList.add('hidden'); addMatchForm.querySelector('form')?.reset(); // Basic reset attempt
             document.getElementById('new-match-date').value = ''; // Clear fields manually too
             document.getElementById('new-match-type').value = ''; document.getElementById('new-match-team1-name').value = ''; document.getElementById('new-match-team1-logo').value = '';
             document.getElementById('new-match-team2-name').value = ''; document.getElementById('new-match-team2-logo').value = ''; document.getElementById('new-match-venue').value = '';
             document.getElementById('new-match-stream').value = 'https://www.twitch.tv/poxelcompetitive/';
             loadMatchesAdmin();
         } catch (error) { showGlobalStatus(`Error adding match: ${error.message}`, true); }
    });
    saveMatchesChangesButton.addEventListener('click', async () => {
        const updates = []; let errorsFound = false;
        document.querySelectorAll('#matches-list .editor-form[data-id]').forEach(editor => { // Use editor-form class
            const id = editor.dataset.id; if (!id) return;
            const matchData = { team1: {}, team2: {} }; let hasError = false;
            const dateInput = editor.querySelector('input[data-field="date"]');
             if (dateInput) {
                 const dateValue = dateInput.value;
                 if (dateValue) { try { matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); } catch (e) { showGlobalStatus(`Error: Invalid date for match ${id}. Fix and save again.`, true); hasError = true; errorsFound = true; } }
                 else { matchData.date = null; } // Allow null date? Or error? Assuming null ok.
             }
             if (!hasError) {
                 editor.querySelectorAll('input[type="text"], input[type="number"]').forEach(input => {
                     if (input.dataset.field === 'date') return;
                     const fieldPath = input.dataset.field; let value = input.value.trim();
                     if (input.maxLength === 2) value = value.toUpperCase(); // Assume logo
                     if (fieldPath?.includes('.')) {
                         const parts = fieldPath.split('.');
                         if (parts.length === 2) { if (!matchData[parts[0]]) matchData[parts[0]] = {}; matchData[parts[0]][parts[1]] = value; }
                     } else if (fieldPath) { matchData[fieldPath] = value; }
                 });
                 if (!matchData.type || !matchData.team1?.name || !matchData.team2?.name) { showGlobalStatus(`Error: Missing Type or Team Names for match ${id}.`, true); hasError = true; errorsFound = true; }
             }
             if (!hasError) updates.push({ id: id, data: matchData });
        });
         if (errorsFound) { showGlobalStatus('Errors found. Fix before saving all changes.', true); return; }
         if (updates.length === 0) { showGlobalStatus('No changes detected.', false); return; }
         showGlobalStatus(`Saving ${updates.length} match changes...`, false);
         const batch = db.batch();
         updates.forEach(update => { batch.update(db.collection('matches').doc(update.id), update.data); });
         try { await batch.commit(); showGlobalStatus(`${updates.length} match(es) updated successfully!`, false); loadMatchesAdmin(); }
         catch (error) { showGlobalStatus(`Error saving match changes: ${error.message}`, true); }
     });

    // --- Leaderboard Management ---
    async function loadLeaderboardAdmin() {
         if (!leaderboardBodyAdmin) return;
         leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>';
         try {
             const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get();
             leaderboardBodyAdmin.innerHTML = ''; let rank = 1;
             if (snapshot.empty) { leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>'; return; }
             snapshot.forEach(doc => {
                 const player = { id: doc.id, ...doc.data() };
                 const row = document.createElement('tr'); row.dataset.id = player.id;
                 const matches = player.matches ?? 0; const wins = player.wins ?? 0; const losses = player.losses ?? 0; const points = player.points ?? 0;
                 row.innerHTML = `
                      <td>${rank++}</td>
                      <td><input type="text" value="${escapeHtml(player.name || '')}" data-field="name" required></td>
                      <td><input type="text" value="${escapeHtml(player.avatar || '')}" data-field="avatar" maxlength="2"></td>
                      <td><input type="number" value="${matches}" data-field="matches" min="0"></td>
                      <td><input type="number" value="${wins}" data-field="wins" min="0"></td>
                      <td><input type="number" value="${losses}" data-field="losses" min="0"></td>
                      <td><input type="number" value="${points}" data-field="points"></td>
                       <td><button class="delete delete-player-button" data-id="${player.id}">Delete</button></td>
                  `;
                 leaderboardBodyAdmin.appendChild(row);
             });
             attachPlayerDeleteListeners();
         } catch (error) { console.error("Error loading leaderboard:", error); leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:var(--red-error);">Error loading leaderboard.</td></tr>'; }
     }
    function attachPlayerDeleteListeners() {
         document.querySelectorAll('#leaderboard-body-admin .delete-player-button').forEach(button => {
             const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button);
             newButton.addEventListener('click', async (e) => {
                 const id = e.target.dataset.id; if (!id) return;
                 const nameInput = e.target.closest('tr')?.querySelector('input[data-field="name"]');
                 const playerName = nameInput ? nameInput.value : `Player ID: ${id}`;
                 if (confirm(`Delete player "${playerName}" (ID: ${id})? This cannot be undone.`)) {
                     try { await db.collection('leaderboard').doc(id).delete(); showGlobalStatus('Player deleted!', false); loadLeaderboardAdmin(); }
                     catch (error) { showGlobalStatus(`Error deleting player: ${error.message}`, true); }
                 }
             });
         });
     }
    addPlayerButton.addEventListener('click', () => { addPlayerForm.classList.toggle('hidden'); });
    saveNewPlayerButton.addEventListener('click', async () => {
         const nameInput = document.getElementById('new-player-name'); const name = nameInput.value.trim(); if (!name) { showGlobalStatus('Error: Player Name is required.', true); nameInput.focus(); return; }
         const avatar = document.getElementById('new-player-avatar').value.trim().toUpperCase();
         const matches = parseInt(document.getElementById('new-player-matches').value) || 0; const wins = parseInt(document.getElementById('new-player-wins').value) || 0;
         const losses = parseInt(document.getElementById('new-player-losses').value) || 0; const points = parseInt(document.getElementById('new-player-points').value) || 0;
         if (isNaN(matches) || isNaN(wins) || isNaN(losses) || isNaN(points)) { showGlobalStatus('Error: Stats must be numbers.', true); return; }
         const newPlayerData = { name, avatar, matches: Math.max(0, matches), wins: Math.max(0, wins), losses: Math.max(0, losses), points };
         showGlobalStatus('Saving new player...', false);
         try {
             await db.collection('leaderboard').add(newPlayerData); showGlobalStatus('New player added!', false); addPlayerForm.classList.add('hidden');
             nameInput.value=''; document.getElementById('new-player-avatar').value=''; document.getElementById('new-player-matches').value='0';
             document.getElementById('new-player-wins').value='0'; document.getElementById('new-player-losses').value='0'; document.getElementById('new-player-points').value='0';
             loadLeaderboardAdmin();
         } catch (error) { showGlobalStatus(`Error adding player: ${error.message}`, true); }
     });
    saveLeaderboardChangesButton.addEventListener('click', async () => {
        const updates = []; let errorsFound = false;
        document.querySelectorAll('#leaderboard-body-admin tr[data-id]').forEach(row => {
            const id = row.dataset.id; if (!id) return;
            const playerData = {}; let hasRowError = false;
            row.querySelectorAll('input').forEach(input => {
                const field = input.dataset.field; if (!field) return; let value = input.value.trim();
                if (input.type === 'number') {
                    const parsedValue = parseInt(value);
                    if (isNaN(parsedValue)) { showGlobalStatus(`Error: Invalid number for ${field} in row ID ${id}.`, true); hasRowError = true; errorsFound = true; }
                    else { value = (field === 'matches' || field === 'wins' || field === 'losses') ? Math.max(0, parsedValue) : parsedValue; }
                } else if (input.type === 'text') {
                    if (field === 'name' && !value) { showGlobalStatus(`Error: Player Name required for ID ${id}.`, true); hasRowError = true; errorsFound = true; }
                    if (field === 'avatar') value = value.toUpperCase();
                }
                if (!errorsFound || (input.type === 'number' && !isNaN(parseInt(input.value)))) playerData[field] = value;
            });
            if (!hasRowError) updates.push({ id: id, data: playerData });
        });
        if (errorsFound) { showGlobalStatus('Errors found. Fix before saving.', true); return; }
        if (updates.length === 0) { showGlobalStatus('No changes detected.', false); return; }
        showGlobalStatus(`Saving ${updates.length} player changes...`, false);
        const batch = db.batch(); updates.forEach(update => { batch.update(db.collection('leaderboard').doc(update.id), update.data); });
        try { await batch.commit(); showGlobalStatus(`${updates.length} player(s) updated!`, false); loadLeaderboardAdmin(); }
        catch (error) { showGlobalStatus(`Error saving leaderboard: ${error.message}`, true); }
    });

    // --- Tournament Bracket Management ---
    async function loadBracketAdmin(bracketType = 'pro') {
         if (!bracketEditor || !bracketLoadingIndicator) return;
         currentBracketType = bracketType; bracketEditor.dataset.type = bracketType;
         bracketLoadingIndicator.classList.remove('hidden'); bracketLoadingIndicator.textContent = `Loading ${bracketType} bracket...`; bracketEditor.innerHTML = '';
         console.log(`--- Loading bracket: ${bracketType} ---`);
         try {
             const docRef = db.collection('brackets').doc(bracketType); const docSnap = await docRef.get();
             if (docSnap.exists) {
                 currentBracketData = docSnap.data() || { rounds: [] };
                 if (!Array.isArray(currentBracketData.rounds)) currentBracketData.rounds = [];
                 currentBracketData.rounds.forEach(round => {
                     if (!round || typeof round !== 'object') round = { name: 'Unnamed', matches: [] };
                     if (!Array.isArray(round.matches)) round.matches = [];
                     round.matches.forEach(match => {
                         if (!match || typeof match !== 'object') match = {};
                         if (!match.team1 || typeof match.team1 !== 'object') match.team1 = { name: '', score: null };
                         if (!match.team2 || typeof match.team2 !== 'object') match.team2 = { name: '', score: null };
                         match.team1.score = (match.team1.score === '' || match.team1.score === undefined) ? null : Number(match.team1.score);
                         match.team2.score = (match.team2.score === '' || match.team2.score === undefined) ? null : Number(match.team2.score);
                         match.completed = !!match.completed;
                         match.winner = match.winner || null;
                         match.winnerName = match.winnerName || '';
                     });
                 });
             } else { currentBracketData = { rounds: [] }; }
             renderBracketEditor();
         } catch (error) { console.error(`Error loading ${bracketType} bracket:`, error); bracketEditor.innerHTML = `<p style="color:var(--red-error);">Error loading bracket: ${error.message}.</p>`; currentBracketData = { rounds: [] }; }
         finally { bracketLoadingIndicator.classList.add('hidden'); }
     }
    function renderBracketEditor() {
         if (!bracketEditor) return; bracketEditor.innerHTML = ''; bracketEditor.dataset.type = currentBracketType;
         const rounds = currentBracketData.rounds || [];
         if (rounds.length === 0) { bracketEditor.innerHTML = '<p class="loading-indicator" style="width: auto; background: none;">No rounds yet. Use "Add New Round".</p>'; }
         else {
             rounds.forEach((round, roundIndex) => {
                 const roundColumnDiv = document.createElement('div'); roundColumnDiv.classList.add('bracket-round-column'); roundColumnDiv.dataset.roundIndex = roundIndex;
                 const roundName = round?.name || `Round ${roundIndex + 1}`;
                 roundColumnDiv.innerHTML = `<h4><input type="text" value="${escapeHtml(roundName)}" class="round-name" placeholder="Round Name" data-round-index="${roundIndex}" data-field="name"><button class="delete delete-round-button" data-round-index="${roundIndex}" title="Delete Round">X</button></h4><div class="matches-in-round"></div><button class="confirm add-match-to-round-button" data-round-index="${roundIndex}" title="Add Match">Add Match</button>`;
                 const matchesContainer = roundColumnDiv.querySelector('.matches-in-round');
                 const matches = round?.matches || [];
                 if (matches.length > 0) { matches.forEach((match, matchIndex) => { matchesContainer.appendChild(renderBracketMatchEditor(match, roundIndex, matchIndex)); }); }
                 else { matchesContainer.innerHTML = '<p style="text-align: center; font-size: 0.9em; color: var(--text-secondary);">No matches yet.</p>'; }
                 bracketEditor.appendChild(roundColumnDiv);
             });
         }
         // Listeners are attached once in loadAdminData/handleBracketSelectChange
     }
    function renderBracketMatchEditor(match, roundIndex, matchIndex) {
        const matchDiv = document.createElement('div'); matchDiv.classList.add('bracket-match-editor');
        matchDiv.dataset.roundIndex = roundIndex; matchDiv.dataset.matchIndex = matchIndex;
        const team1Name = match?.team1?.name || ''; const team1Score = (match?.team1?.score === null || match?.team1?.score === undefined) ? '' : match.team1.score;
        const team2Name = match?.team2?.name || ''; const team2Score = (match?.team2?.score === null || match?.team2?.score === undefined) ? '' : match.team2.score;
        const winnerName = match?.winnerName || ''; const completed = match?.completed || false;
        matchDiv.innerHTML = `<h5>Match ${matchIndex + 1}<button class="delete delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}" title="Delete Match">X</button></h5>
            <label>Team 1:</label> <input type="text" value="${escapeHtml(team1Name)}" class="bracket-team1-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.name">
            <label>Score 1:</label> <input type="number" value="${team1Score}" class="bracket-team1-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.score" min="0">
            <label>Team 2:</label> <input type="text" value="${escapeHtml(team2Name)}" class="bracket-team2-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.name">
            <label>Score 2:</label> <input type="number" value="${team2Score}" class="bracket-team2-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.score" min="0">
            <label>Winner Name:</label> <input type="text" value="${escapeHtml(winnerName)}" class="bracket-winner-name" placeholder="Enter winning team name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="winnerName">
            <label class="checkbox-label"><input type="checkbox" ${completed ? 'checked' : ''} class="bracket-match-completed" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="completed"> Completed</label>`;
        return matchDiv;
     }
    function attachBracketEditorListeners() {
        console.log("Attaching bracket editor listeners.");
        if (!bracketEditor) return;
        // Use event delegation on the editor container
        bracketEditor.removeEventListener('click', handleBracketButtonClick); bracketEditor.removeEventListener('input', handleBracketInput); bracketEditor.removeEventListener('change', handleBracketInput);
        bracketEditor.addEventListener('click', handleBracketButtonClick); bracketEditor.addEventListener('input', handleBracketInput); bracketEditor.addEventListener('change', handleBracketInput); // For checkboxes
        // Listeners for controls outside the editor div
        if (addRoundButton) { addRoundButton.removeEventListener('click', handleAddRoundClick); addRoundButton.addEventListener('click', handleAddRoundClick); }
        if (saveBracketChangesButton) { saveBracketChangesButton.removeEventListener('click', handleSaveBracketClick); saveBracketChangesButton.addEventListener('click', handleSaveBracketClick); }
        if (bracketSelect) { bracketSelect.removeEventListener('change', handleBracketSelectChange); bracketSelect.addEventListener('change', handleBracketSelectChange); }
    }
    function handleBracketSelectChange(e) { loadBracketAdmin(e.target.value); attachBracketEditorListeners(); /* Re-attach after load */ }
    function handleAddRoundClick() {
        if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) currentBracketData = { rounds: [] };
        currentBracketData.rounds.push({ name: `Round ${currentBracketData.rounds.length + 1}`, matches: [] });
        renderBracketEditor();
     }
    async function handleSaveBracketClick() {
         if (!currentBracketType || !currentBracketData || !Array.isArray(currentBracketData.rounds)) { showGlobalStatus('Error: Bracket data invalid.', true); return; }
         let dataToSave; try { dataToSave = JSON.parse(JSON.stringify(currentBracketData)); } catch (e) { showGlobalStatus('Error: Failed to prepare data.', true); return; }
         let validationError = false;
         dataToSave.rounds.forEach((round, rIdx) => {
             if (!round || typeof round !== 'object') { validationError = true; return; } round.name = round.name ? round.name.trim() : `Round ${rIdx + 1}`;
             if (!Array.isArray(round.matches)) round.matches = [];
             round.matches.forEach((match, mIdx) => {
                 if (!match || typeof match !== 'object') { validationError = true; return; }
                 if (!match.team1 || typeof match.team1 !== 'object') match.team1 = {}; if (!match.team2 || typeof match.team2 !== 'object') match.team2 = {};
                 match.team1.name = match.team1.name ? match.team1.name.trim() : ''; match.team2.name = match.team2.name ? match.team2.name.trim() : '';
                 match.team1.score = (match.team1.score === '' || match.team1.score === undefined || match.team1.score === null) ? null : Number(match.team1.score);
                 match.team2.score = (match.team2.score === '' || match.team2.score === undefined || match.team2.score === null) ? null : Number(match.team2.score);
                 if ((isNaN(match.team1.score) && match.team1.score !== null) || (isNaN(match.team2.score) && match.team2.score !== null)) { showGlobalStatus(`Error: Invalid score in R${rIdx+1} M${mIdx+1}.`, true); validationError = true; }
                 match.completed = !!match.completed; match.winnerName = match.winnerName ? match.winnerName.trim() : '';
                 match.winner = null; // Reset winner logic
                 if (match.completed && match.winnerName) {
                     const wnLower = match.winnerName.toLowerCase(); const t1nLower = match.team1.name?.toLowerCase(); const t2nLower = match.team2.name?.toLowerCase();
                     if (t1nLower && wnLower === t1nLower) match.winner = match.team1.name; else if (t2nLower && wnLower === t2nLower) match.winner = match.team2.name;
                 }
             });
         });
         if (validationError) { showGlobalStatus('Validation errors found in bracket data. Fix and save again.', true); return; }
         showGlobalStatus(`Saving ${currentBracketType} bracket changes...`, false);
         try { await db.collection('brackets').doc(currentBracketType).set(dataToSave); showGlobalStatus(`${currentBracketType} bracket saved!`, false); }
         catch (error) { showGlobalStatus(`Error saving bracket: ${error.message}`, true); }
     }
    function handleBracketButtonClick(event) {
        const target = event.target.closest('button'); // Find the button clicked or ancestor button
        if (!target) return;
        const roundIndexStr = target.dataset.roundIndex; const matchIndexStr = target.dataset.matchIndex;
        if (target.classList.contains('delete-round-button') && roundIndexStr !== undefined) { deleteBracketRoundFromState(parseInt(roundIndexStr)); }
        else if (target.classList.contains('add-match-to-round-button') && roundIndexStr !== undefined) { addBracketMatchToState(parseInt(roundIndexStr)); }
        else if (target.classList.contains('delete-match-from-round-button') && roundIndexStr !== undefined && matchIndexStr !== undefined) { deleteBracketMatchFromState(parseInt(roundIndexStr), parseInt(matchIndexStr)); }
     }
    function handleBracketInput(event) {
        const target = event.target; if (!target || !(target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) return;
        const roundIndexStr = target.dataset.roundIndex; const matchIndexStr = target.dataset.matchIndex; const field = target.dataset.field;
        if (roundIndexStr === undefined || field === undefined) return;
        const roundIndex = parseInt(roundIndexStr); const matchIndex = (matchIndexStr !== undefined) ? parseInt(matchIndexStr) : null;
        if (isNaN(roundIndex) || (matchIndexStr !== undefined && isNaN(matchIndex))) return;
        try {
            if (!currentBracketData?.rounds?.[roundIndex]) return; const round = currentBracketData.rounds[roundIndex];
            if (matchIndex === null) { if (field === 'name') round.name = target.value.trim(); }
            else {
                if (!round.matches?.[matchIndex]) return; const match = round.matches[matchIndex];
                let value = (target.type === 'checkbox') ? target.checked : (target.type === 'number') ? (target.value === '' ? null : parseInt(target.value)) : target.value;
                 if (target.type === 'number' && isNaN(value) && target.value !== '') value = null; // Handle NaN parsing
                if (field.includes('.')) {
                    const parts = field.split('.'); if (parts.length === 2) { if (!match[parts[0]]) match[parts[0]] = {}; match[parts[0]][parts[1]] = value; }
                } else { match[field] = value; }
            }
        } catch (error) { console.error("Error updating state from input:", error); }
     }
    function deleteBracketRoundFromState(roundIndex) {
         if (!currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length) return;
         const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
         if (confirm(`Delete "${roundName}" and all its matches? (Temporary until saved)`)) {
             currentBracketData.rounds.splice(roundIndex, 1); renderBracketEditor();
         }
     }
    function addBracketMatchToState(roundIndex) {
         if (!currentBracketData?.rounds?.[roundIndex]) return;
         if (!Array.isArray(currentBracketData.rounds[roundIndex].matches)) currentBracketData.rounds[roundIndex].matches = [];
         const newMatch = { team1: { name: '', score: null }, team2: { name: '', score: null }, winnerName: '', winner: null, completed: false };
         currentBracketData.rounds[roundIndex].matches.push(newMatch); renderBracketEditor();
    }
    function deleteBracketMatchFromState(roundIndex, matchIndex) {
         if (!currentBracketData?.rounds?.[roundIndex]?.matches || matchIndex < 0 || matchIndex >= currentBracketData.rounds[roundIndex].matches.length) return;
         const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
         if (confirm(`Delete Match ${matchIndex + 1} from "${roundName}"? (Temporary until saved)`)) {
             currentBracketData.rounds[roundIndex].matches.splice(matchIndex, 1); renderBracketEditor();
         }
    }

    // --- Ban User Management ---
    function showBanStatus(message, isError = false) {
        console.log(`Ban Status: ${message} (Error: ${isError})`);
        if (!banStatus) return;
        banStatus.textContent = message;
        banStatus.style.color = isError ? 'var(--red-error)' : 'var(--green-live)';
        setTimeout(() => { if (banStatus.textContent === message) banStatus.textContent = ''; }, isError ? 6000 : 4000);
    }

    banUserButton.addEventListener('click', async () => {
        const uidToBan = banUserUidInput.value.trim();
        const reason = banReasonInput.value.trim();
        if (!uidToBan || !reason) { showBanStatus("Error: Both UID and Reason are required.", true); return; }
        if (uidToBan.includes(' ') || uidToBan.length < 5) { showBanStatus("Error: Invalid User UID format.", true); return; }

        if (!confirm(`Ban user UID: ${uidToBan} for reason: "${reason}"?`)) { showBanStatus("Ban cancelled.", false); return; }
        showBanStatus("Banning user...", false);
        try {
            const banDocRef = db.collection('banned_users').doc(uidToBan);
            await banDocRef.set({
                reason: reason, bannedAt: firebase.firestore.FieldValue.serverTimestamp(),
                bannedByUid: auth.currentUser?.uid || 'unknown', bannedByEmail: auth.currentUser?.email || 'unknown'
            }, { merge: true }); // Use merge just in case
            showBanStatus("User banned successfully!", false);
            banUserUidInput.value = ''; banReasonInput.value = '';
            loadBannedUsers(); // Refresh list
        } catch (error) { showBanStatus(`Error banning user: ${error.message}`, true); }
    });

    async function loadBannedUsers() {
        if (!bannedUsersTableBody || !bannedUsersLoading) return;
        bannedUsersLoading.classList.remove('hidden'); bannedUsersLoading.textContent = "Loading banned users..."; bannedUsersTableBody.innerHTML = '';
        try {
            const snapshot = await db.collection('banned_users').orderBy('bannedAt', 'desc').get();
            if (snapshot.empty) { bannedUsersTableBody.innerHTML = '<tr><td colspan="5">No users are currently banned.</td></tr>'; }
            else {
                snapshot.forEach(doc => {
                    const banData = doc.data(); const uid = doc.id; const reason = banData.reason || 'N/A';
                    let bannedAtStr = 'Unknown'; if (banData.bannedAt?.toDate) { try { bannedAtStr = banData.bannedAt.toDate().toLocaleString(); } catch (e) { } }
                    const bannedBy = banData.bannedByEmail || banData.bannedByUid || 'Unknown';
                    const row = document.createElement('tr');
                    row.innerHTML = `<td>${escapeHtml(uid)}</td><td>${escapeHtml(reason)}</td><td>${escapeHtml(bannedAtStr)}</td><td>${escapeHtml(bannedBy)}</td>
                        <td><button class="unban unban-button" data-uid="${uid}">Unban</button></td>`;
                    bannedUsersTableBody.appendChild(row);
                });
                attachUnbanListeners();
            }
            bannedUsersLoading.classList.add('hidden');
        } catch (error) {
            console.error("Error loading banned users:", error);
            bannedUsersTableBody.innerHTML = '<tr><td colspan="5" style="color:var(--red-error);">Error loading list.</td></tr>';
            bannedUsersLoading.textContent = "Error loading list."; bannedUsersLoading.classList.remove('hidden');
        }
    }

    function attachUnbanListeners() {
         document.querySelectorAll('.unban-button').forEach(button => {
             const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button);
             newButton.addEventListener('click', async (e) => {
                 const uidToUnban = e.target.dataset.uid; if (!uidToUnban) return;
                 if (confirm(`Unban user UID: ${uidToUnban}?`)) {
                     showBanStatus(`Unbanning ${uidToUnban}...`, false);
                     try { await db.collection('banned_users').doc(uidToUnban).delete(); showBanStatus("User unbanned!", false); loadBannedUsers(); }
                     catch (error) { showBanStatus(`Error unbanning: ${error.message}`, true); }
                 } else { showBanStatus("Unban cancelled.", false); }
             });
         });
    }
    refreshBannedListButton.addEventListener('click', loadBannedUsers);

    // --- Initial Load Call ---
    console.log("Admin script initialized. Waiting for authentication state...");

    // --- Window Unload Cleanup ---
    window.addEventListener('beforeunload', (event) => {
        if (currentUserId && auth.currentUser) {
            console.log("beforeunload: Attempting quick presence removal.");
            db.collection(PRESENCE_COLLECTION).doc(currentUserId).delete().catch(err => {}); // Fire and forget
        }
    });

    // --- END OF SCRIPT --- //
</script>

</body>
</html>
