<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <link rel="icon" type="image/x-icon" href="https://res.cloudinary.com/djttn4xvk/image/upload/v1744016662/iv8s8dkwdzxgnubsnhla.ico"> <!-- Added Favicon Back -->
    <style>
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722;
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
            --green-live: #2ecc71; /* Added live indicator color */
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; }
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        h1, h2 { color: var(--orange); }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #555; cursor: not-allowed; } /* Style for disabled button */
        #logout-button { background-color: #555; }
        .admin-section { margin-top: 20px; border-top: 1px solid #444; padding-top: 20px; }
        label { display: block; margin-bottom: 5px; color: var(--text-secondary); }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select { /* Added select */
            width: calc(95% - 18px); /* Adjust width considering padding/border */
            padding: 8px;
            margin-bottom: 10px;
            background-color: #333;
            border: 1px solid #555;
            color: var(--text);
            border-radius: 4px;
        }
        input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }
        label[for] {
            cursor: pointer; /* Indicate checkbox label is clickable */
        }

        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); }

        .match-editor, .player-editor {
             margin-bottom: 15px; padding: 10px; border: 1px dashed #555; border-radius: 5px;
        }

        /* --- Bracket Editor Styles --- */
        #bracket-editor { display: flex; overflow-x: auto; padding-bottom: 15px; gap: 20px; }
        .bracket-round-column { flex: 0 0 300px; min-width: 250px; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: var(--dark-accent); display: flex; flex-direction: column; gap: 15px; }
        .bracket-round-column h4 { margin-top: 0; padding-bottom: 10px; border-bottom: 1px dashed #555; display: flex; justify-content: space-between; align-items: center; }
        .bracket-round-column h4 input[type="text"] { flex-grow: 1; margin-right: 10px; padding: 5px; width: auto; }
        .bracket-match-editor { padding: 10px; border: 1px solid #555; border-radius: 4px; background-color: var(--dark); display: flex; flex-direction: column; gap: 5px; }
        .bracket-match-editor h5 { margin-top: 0; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; font-size: 1em; }
        .bracket-match-editor h5 button { padding: 3px 8px; font-size: 0.8em; margin: 0; background-color: #c0392b; }
        .bracket-round-column h4 button { padding: 3px 8px; font-size: 0.8em; margin: 0; background-color: #c0392b; }
        .bracket-match-editor label { font-size: 0.9em; margin-bottom: 0; }
        .bracket-match-editor input[type="text"], .bracket-match-editor input[type="number"] { width: calc(100% - 18px); padding: 4px; margin-bottom: 5px; font-size: 0.9em; }
        .bracket-match-editor .checkbox-label { display: flex; align-items: center; margin-top: 5px; font-size: 0.9em; }
        .bracket-match-editor .checkbox-label input[type="checkbox"] { margin-right: 5px; margin-bottom: 0; }
        .bracket-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid #444; }
        .bracket-controls button { margin-right: 10px; }
        .loading-indicator { font-style: italic; color: var(--text-secondary); padding: 10px; text-align: center; width: 100%; box-sizing: border-box; }

        /* --- Online Users Presence Styles --- */
        #online-users-section { margin-bottom: 20px; padding: 15px; background-color: var(--dark-accent); border-radius: 8px; border: 1px solid #444; }
        #online-users-section h4 { margin-top: 0; margin-bottom: 15px; color: var(--text-secondary); font-size: 0.9em; font-weight: normal; border-bottom: 1px dashed #555; padding-bottom: 10px; }
        #online-users-container { display: flex; flex-wrap: wrap; gap: 20px; }
        .user-presence-indicator { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .user-presence-circle { width: 40px; height: 40px; border-radius: 50%; background-color: var(--orange); color: var(--dark); display: flex; align-items: center; justify-content: center; font-size: 1.2em; font-weight: bold; margin-bottom: 5px; border: 3px solid transparent; box-sizing: border-box; text-transform: uppercase; }
        .user-presence-circle.live { border-color: var(--green-live); }
        .user-presence-name { font-size: 0.8em; color: var(--text-secondary); max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    </style>
</head>
<body>

<h1>Poxel Competitive - Admin</h1>

<!-- Login Section -->
<div id="login-container">
    <h2>Admin Login</h2>
    <p>Please log in with your authorized Google account.</p>
    <button id="login-button">Login with Google</button>
    <p id="login-error" style="color: red;"></p>
    <p id="auth-check-message" style="color: orange;"></p>
</div>

<!-- Admin Panel (Initially Hidden) -->
<div id="admin-panel" class="hidden">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2>Management Dashboard</h2>
        <div>
            <span id="user-info" style="margin-right: 15px;"></span>
            <button id="logout-button">Logout</button>
        </div>
    </div>

    <!-- START: Online Users Section -->
    <div id="online-users-section">
        <h4>Online Admins:</h4>
        <div id="online-users-container">
            <div class="loading-indicator">Loading presence...</div>
            <!-- Online users will be rendered here -->
        </div>
    </div>
    <!-- END: Online Users Section -->

    <p style="color: lightgreen;" id="save-status"></p>

    <!-- Upcoming Matches Management -->
    <div class="admin-section">
        <h3>Upcoming Matches Management</h3>
        <div id="matches-list"></div>
        <button id="add-match-button">Add New Match</button>
        <div id="add-match-form" class="match-editor hidden">
             <h4>New Match Details</h4>
             <label for="new-match-date">Date & Time:</label>
             <input type="datetime-local" id="new-match-date">
             <label for="new-match-type">Type (e.g., Quarterfinals):</label>
             <input type="text" id="new-match-type">
             <label for="new-match-team1-name">Team 1 Name:</label>
             <input type="text" id="new-match-team1-name">
             <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
             <input type="text" id="new-match-team1-logo" maxlength="2">
             <label for="new-match-team2-name">Team 2 Name:</label>
             <input type="text" id="new-match-team2-name">
             <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
             <input type="text" id="new-match-team2-logo" maxlength="2">
             <label for="new-match-venue">Venue:</label>
             <input type="text" id="new-match-venue">
             <label for="new-match-stream">Stream Link:</label>
             <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
             <button id="save-new-match">Save New Match</button>
             <button type="button" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
        </div>
        <button id="save-matches-changes">Save All Match Changes</button>
    </div>

    <!-- Leaderboard Management -->
    <div class="admin-section">
        <h3>Leaderboard Management</h3>
        <div id="leaderboard-list">
             <table>
                 <thead>
                     <tr>
                         <th>Rank</th><th>Player Name</th><th>Avatar</th><th>Matches</th><th>Wins</th><th>Losses</th><th>Points</th><th>Actions</th>
                     </tr>
                 </thead>
                 <tbody id="leaderboard-body-admin"></tbody>
             </table>
        </div>
         <button id="add-player-button">Add New Player</button>
         <div id="add-player-form" class="player-editor hidden">
             <h4>New Player Details</h4>
             <label>Name:</label><input type="text" id="new-player-name">
             <label>Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
             <label>Matches:</label><input type="number" id="new-player-matches" value="0" min="0">
             <label>Wins:</label><input type="number" id="new-player-wins" value="0" min="0">
             <label>Losses:</label><input type="number" id="new-player-losses" value="0" min="0">
             <label>Points:</label><input type="number" id="new-player-points" value="0">
             <button id="save-new-player">Save New Player</button>
             <button type="button" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
        </div>
        <button id="save-leaderboard-changes">Save Leaderboard Changes</button>
    </div>

    <!-- Tournament Bracket Management -->
    <div class="admin-section">
        <h3>Tournament Bracket Management</h3>
        <label for="bracket-select">Select Bracket:</label>
        <select id="bracket-select">
            <option value="pro">Pro Tourney</option>
            <option value="novice">Novice Tourney</option>
        </select>
         <div id="bracket-loading-indicator" class="loading-indicator hidden">Loading...</div>
        <div id="bracket-editor"></div>
        <div class="bracket-controls">
             <button id="add-round-button">Add New Round</button>
             <button id="save-bracket-changes">Save Bracket Changes</button>
              <p><i>Note: This view arranges rounds horizontally...</i></p>
        </div>
    </div>

</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

<script>
    // --- START OF SCRIPT --- //

    const firebaseConfig = {
          apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI", // Replace with your actual config if different
          authDomain: "poxelcomp.firebaseapp.com",
          projectId: "poxelcomp",
          storageBucket: "poxelcomp.firebasestorage.app",
          messagingSenderId: "620490990104",
          appId: "1:620490990104:web:709023eb464c7d886b996d",
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // --- DOM Elements ---
    const loginContainer = document.getElementById('login-container');
    const adminPanel = document.getElementById('admin-panel');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userInfo = document.getElementById('user-info');
    const loginError = document.getElementById('login-error');
    const authCheckMessage = document.getElementById('auth-check-message');
    const saveStatus = document.getElementById('save-status');
    const onlineUsersContainer = document.getElementById('online-users-container');
    const matchesList = document.getElementById('matches-list');
    const addMatchButton = document.getElementById('add-match-button');
    const addMatchForm = document.getElementById('add-match-form');
    const saveNewMatchButton = document.getElementById('save-new-match');
    const saveMatchesChangesButton = document.getElementById('save-matches-changes');
    const leaderboardList = document.getElementById('leaderboard-list');
    const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
    const addPlayerButton = document.getElementById('add-player-button');
    const addPlayerForm = document.getElementById('add-player-form');
    const saveNewPlayerButton = document.getElementById('save-new-player'); // The button we are modifying the listener for
    const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');
    const bracketSelect = document.getElementById('bracket-select');
    const bracketEditor = document.getElementById('bracket-editor');
    const bracketLoadingIndicator = document.getElementById('bracket-loading-indicator');
    const addRoundButton = document.getElementById('add-round-button');
    const saveBracketChangesButton = document.getElementById('save-bracket-changes');

    // --- Global State ---
    let currentBracketData = { rounds: [] };
    let currentBracketType = 'pro';
    let currentUserId = null;
    let presenceUpdateInterval = null;
    let onlineUsersListenerUnsubscribe = null;

    // --- Authorization Check ---
    async function checkAdminAuthorization(uid) {
        console.log(`Checking authorization for UID: ${uid}`);
        authCheckMessage.textContent = 'Checking authorization...';
        authCheckMessage.style.color = 'orange';
        try {
            const adminDoc = await db.collection('admins').doc(uid).get();
            if (adminDoc.exists) {
                console.log(`UID ${uid} IS authorized (found in 'admins' collection).`);
                authCheckMessage.textContent = '';
                return true;
            } else {
                console.log(`UID ${uid} is NOT authorized (document not found in 'admins' collection).`);
                authCheckMessage.textContent = 'Access Denied: Your account is not authorized for the admin panel.';
                authCheckMessage.style.color = 'red';
                return false;
            }
        } catch (error) {
            console.error("Error checking admin authorization:", error);
            authCheckMessage.textContent = `Error checking authorization: ${error.message}`;
            authCheckMessage.style.color = 'red';
            return false;
        }
    }

    // --- Presence Management ---
    const PRESENCE_COLLECTION = 'online_users';
    const PRESENCE_TIMEOUT_MS = 90 * 1000; // 90 seconds
    const PRESENCE_UPDATE_INTERVAL_MS = 60 * 1000; // 60 seconds

    async function registerPresence(user) {
        if (!user || !user.uid) return;
        currentUserId = user.uid;
        const presenceRef = db.collection(PRESENCE_COLLECTION).doc(user.uid);
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName || user.email.split('@')[0],
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        };

        try {
            console.log(`Registering presence for ${user.email} (UID: ${user.uid})`);
            await presenceRef.set(userData, { merge: true });

            // Start periodic update
            if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
            presenceUpdateInterval = setInterval(async () => {
                if (auth.currentUser && auth.currentUser.uid === currentUserId) {
                    try {
                        // console.log(`Updating lastSeen for ${currentUserId}`); // Can be noisy
                        await presenceRef.update({ lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
                    } catch (error) {
                        console.error("Error updating presence timestamp:", error);
                        // Consider stopping interval if permissions error occurs
                        if (error.code === 'permission-denied') {
                             console.error("Permission denied updating timestamp. Stopping interval.");
                             clearInterval(presenceUpdateInterval);
                             presenceUpdateInterval = null;
                        }
                    }
                } else {
                    console.warn("User logged out or changed, stopping presence update interval.");
                    clearInterval(presenceUpdateInterval);
                    presenceUpdateInterval = null;
                }
            }, PRESENCE_UPDATE_INTERVAL_MS);

            // Start listening for online users
            listenForOnlineAdmins();

        } catch (error) {
            console.error("Error registering initial presence:", error);
             // Show error to user?
             if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:red;">Error setting up presence.</div>';
        }
    }

    async function removePresence(uid) {
        if (!uid) return;
        console.log(`Removing presence for UID: ${uid}`);
        if (presenceUpdateInterval) {
            clearInterval(presenceUpdateInterval);
            presenceUpdateInterval = null;
        }
        if (onlineUsersListenerUnsubscribe) {
            onlineUsersListenerUnsubscribe();
            onlineUsersListenerUnsubscribe = null;
             console.log("Detached online users listener.");
        }
        try {
            // No need to await if signing out, fire and forget is ok
            db.collection(PRESENCE_COLLECTION).doc(uid).delete();
            console.log(`Presence document delete request sent for ${uid}`);
        } catch (error) {
            // Log error, but don't block sign-out process
            console.error("Error removing presence document:", error);
        }
        currentUserId = null;
        if(onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator">Logged out.</div>';
    }

    // --- Listener for Online Admins ---
    function listenForOnlineAdmins() {
        console.log("Starting listener for online admins (v2 - checks activity only)...");
        if (onlineUsersListenerUnsubscribe) {
            console.log("Detaching existing online users listener before attaching new one.");
            onlineUsersListenerUnsubscribe();
        }

        if (!currentUserId) {
            console.warn("listenForOnlineAdmins called before currentUserId is set. Aborting listener setup.");
             if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:orange;">Waiting for user authentication...</div>';
            return;
        }

        const query = db.collection(PRESENCE_COLLECTION);
        onlineUsersListenerUnsubscribe = query.onSnapshot((snapshot) => {
            console.log(`Presence snapshot received: ${snapshot.size} total potential documents.`);
            const now = Date.now();
            const activeUsers = []; // Renamed from onlineAdmins for clarity

            snapshot.forEach(doc => {
                const user = doc.data();
                // Basic Validation
                if (!user || !user.uid || !user.email) {
                    console.warn("Skipping presence doc with missing basic data (uid/email):", doc.id, user);
                    return;
                }
                if (!user.lastSeen) {
                    console.warn(`Skipping presence doc for ${user.email} (UID: ${user.uid}) due to missing 'lastSeen' field.`);
                    return;
                }

                // Check Activity
                let lastSeenTime = null;
                try {
                    // Crucial: Ensure lastSeen is a Firestore Timestamp before calling toDate()
                    if (typeof user.lastSeen.toDate !== 'function') {
                         throw new Error("lastSeen field is not a Firestore Timestamp object.");
                    }
                    lastSeenTime = user.lastSeen.toDate().getTime();
                } catch (e) {
                    console.error(`Error converting lastSeen to Date for user ${user.uid}. Skipping user.`, { lastSeenValue: user.lastSeen, error: e });
                    return; // Skip this user if timestamp is invalid
                }

                if (now - lastSeenTime < PRESENCE_TIMEOUT_MS) {
                    activeUsers.push(user);
                } else {
                    console.log(`User ${user.email} (UID: ${user.uid}) last seen ${Math.round((now - lastSeenTime)/1000)}s ago. Considered inactive.`);
                }
            });

            console.log(`Rendering ${activeUsers.length} active users (including self if active).`);
            renderOnlineUsers(activeUsers); // Render the list of *active* users

        }, (error) => {
            console.error("Error in presence listener snapshot:", error);
            if(onlineUsersContainer) onlineUsersContainer.innerHTML = `<div class="loading-indicator" style="color:red;">Error listening for presence: ${error.message}</div>`;
            if (onlineUsersListenerUnsubscribe) {
                onlineUsersListenerUnsubscribe();
                onlineUsersListenerUnsubscribe = null;
                 console.log("Detached presence listener due to error.");
            }
        });
         console.log("Presence listener attached successfully.");
    }

    function renderOnlineUsers(users) {
        if (!onlineUsersContainer) return;
        onlineUsersContainer.innerHTML = '';

        if (users.length === 0) {
            onlineUsersContainer.innerHTML = '<div class="loading-indicator">No admins currently active.</div>';
            return;
        }

        users.sort((a, b) => (a.displayName || a.email).localeCompare(b.displayName || b.email));

        users.forEach(user => {
            const indicatorDiv = document.createElement('div');
            indicatorDiv.classList.add('user-presence-indicator');
            const circleDiv = document.createElement('div');
            circleDiv.classList.add('user-presence-circle', 'live');
            const initial = user.email ? user.email.charAt(0).toUpperCase() : '?';
            circleDiv.textContent = initial;
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('user-presence-name');
            let name = user.displayName ? user.displayName.split(' ')[0] : user.email.split('@')[0];
            name = name.charAt(0).toUpperCase() + name.slice(1);
            nameSpan.textContent = name;
            nameSpan.title = user.email;
            indicatorDiv.appendChild(circleDiv);
            indicatorDiv.appendChild(nameSpan);
            onlineUsersContainer.appendChild(indicatorDiv);
        });
    }


    // --- Authentication ---
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            console.log("Auth state changed: User signed in.", { email: user.email, uid: user.uid, displayName: user.displayName });
            loginError.textContent = '';
            authCheckMessage.textContent = '';
            const isAuthorized = await checkAdminAuthorization(user.uid);
            if (isAuthorized) {
                console.log("Authorization successful. Loading admin panel & presence.");
                loginContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                adminPanel.classList.add('fade-in');
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;
                await registerPresence(user);
                loadAdminData();
            } else {
                console.log("Authorization check failed.");
                userInfo.textContent = '';
                adminPanel.classList.add('hidden');
                loginContainer.classList.remove('hidden');
            }
        } else {
            console.log("Auth state changed: User signed out.");
            if (currentUserId) {
                await removePresence(currentUserId);
            }
            adminPanel.classList.add('hidden');
            adminPanel.classList.remove('fade-in');
            loginContainer.classList.remove('hidden');
            userInfo.textContent = '';
            loginError.textContent = '';
            authCheckMessage.textContent = '';
            clearAdminUI();
        }
    });

    // --- Login/Logout Buttons ---
    loginButton.addEventListener('click', () => {
        loginError.textContent = '';
        authCheckMessage.textContent = '';
        console.log("Login button clicked. Attempting Google Sign-in...");
        auth.signInWithPopup(googleProvider)
             .then((result) => {
                console.log("Sign-in popup successful for:", result?.user?.email);
             })
            .catch((error) => {
                console.error("Google Sign-in failed:", error);
                loginError.textContent = `Login failed: ${error.message}`;
                 if (error.code === 'auth/popup-closed-by-user') { loginError.textContent = 'Login cancelled.'; }
                 else if (error.code === 'auth/cancelled-popup-request') { loginError.textContent = 'Login popup issue. Please try again.'; }
                 else if (error.code === 'auth/popup-blocked') { loginError.textContent = 'Login popup blocked by browser. Please allow popups for this site.'; }
                authCheckMessage.textContent = '';
            });
    });

    logoutButton.addEventListener('click', async () => {
        console.log("Logout button clicked.");
        try {
            await auth.signOut();
            console.log("Sign-out successful via button click.");
        } catch (error) {
            console.error("Error during sign out:", error);
            showSaveStatus(`Logout error: ${error.message}`, true);
        }
    });

    // --- UI Clearing ---
    function clearAdminUI() {
         console.log("Clearing Admin UI state...");
        if (matchesList) matchesList.innerHTML = '';
        if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = '';
        if (bracketEditor) bracketEditor.innerHTML = '';
        if (saveStatus) saveStatus.textContent = '';
         if (addMatchForm) addMatchForm.classList.add('hidden');
         if (addPlayerForm) addPlayerForm.classList.add('hidden');
         currentBracketData = { rounds: [] };
         currentBracketType = 'pro';
         if (bracketSelect) bracketSelect.value = 'pro';
         if (onlineUsersContainer) onlineUsersContainer.innerHTML = '';
          if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
          presenceUpdateInterval = null;
          if (onlineUsersListenerUnsubscribe) onlineUsersListenerUnsubscribe();
          onlineUsersListenerUnsubscribe = null;
          currentUserId = null;
          console.log("Admin UI Cleared.");
    }

    // --- Data Loading (Main Admin Sections) ---
    function loadAdminData() {
         console.log("Loading main admin data sections (matches, leaderboard, bracket)...");
        loadMatchesAdmin();
        loadLeaderboardAdmin();
         if (bracketSelect) {
            currentBracketType = bracketSelect.value;
            loadBracketAdmin(currentBracketType);
         } else {
             console.error("bracketSelect element not found during data load.");
             loadBracketAdmin('pro');
         }
    }

    // --- Matches Load/Save/Delete ---
    async function loadMatchesAdmin() {
        if (!matchesList) { console.error("loadMatchesAdmin: matchesList element not found"); return; }
        matchesList.innerHTML = '<div class="loading-indicator">Loading matches...</div>';
        console.log("Loading matches from Firestore...");
        try {
            const snapshot = await db.collection('matches').orderBy('date', 'desc').get();
            console.log(`Found ${snapshot.size} matches.`);
            matchesList.innerHTML = '';
            if (snapshot.empty) {
                matchesList.innerHTML = '<p>No matches found.</p>';
                return;
            }
            snapshot.forEach(doc => {
                const match = { id: doc.id, ...doc.data() };
                const dateForInput = match.date?.toDate ? new Date(match.date.toDate().getTime() - match.date.toDate().getTimezoneOffset() * 60000).toISOString().slice(0, 16) : '';
                const matchDiv = document.createElement('div');
                matchDiv.classList.add('match-editor');
                matchDiv.dataset.id = match.id;
                 matchDiv.innerHTML = `
                     <h4>Match ID: ${match.id}</h4>
                     <label>Date:</label><input type="datetime-local" value="${dateForInput}" data-field="date">
                     <label>Type:</label><input type="text" value="${match.type || ''}" data-field="type">
                     <label>Team 1:</label><input type="text" value="${match.team1?.name || ''}" data-field="team1.name">
                     <label>Team 1 Logo:</label><input type="text" value="${match.team1?.logo || ''}" data-field="team1.logo" maxlength="2">
                     <label>Team 2:</label><input type="text" value="${match.team2?.name || ''}" data-field="team2.name">
                     <label>Team 2 Logo:</label><input type="text" value="${match.team2?.logo || ''}" data-field="team2.logo" maxlength="2">
                     <label>Venue:</label><input type="text" value="${match.venue || ''}" data-field="venue">
                     <label>Stream:</label><input type="text" value="${match.streamLink || ''}" data-field="streamLink">
                     <button class="delete-match-button" data-id="${match.id}">Delete Match</button>
                 `;
                matchesList.appendChild(matchDiv);
            });
             attachMatchDeleteListeners();
        } catch (error) {
            console.error("Error loading matches:", error);
            matchesList.innerHTML = '<p style="color:red;">Error loading matches.</p>';
        }
     }
    function attachMatchDeleteListeners() {
        document.querySelectorAll('#matches-list .delete-match-button').forEach(button => {
             const newButton = button.cloneNode(true);
             button.parentNode.replaceChild(newButton, button);
             newButton.addEventListener('click', async (e) => {
                 const id = e.target.dataset.id;
                 console.log(`Attempting to delete match ID: ${id}`);
                 if (confirm(`Are you sure you want to delete match ${id}?`)) {
                     try {
                         await db.collection('matches').doc(id).delete();
                         console.log(`Match ${id} deleted.`);
                         showSaveStatus('Match deleted successfully!', false);
                         loadMatchesAdmin();
                     } catch (error) {
                         console.error("Error deleting match:", error);
                         showSaveStatus(`Error deleting match: ${error.message}`, true);
                     }
                 } else { console.log("Deletion cancelled."); }
             });
         });
    }
    addMatchButton.addEventListener('click', () => {
        console.log("Toggle Add New Match form visibility.");
          if (addMatchForm) addMatchForm.classList.toggle('hidden');
    });
    saveNewMatchButton.addEventListener('click', async () => {
        console.log("Attempting to save NEW match...");
         const dateValue = document.getElementById('new-match-date').value;
         let matchDateTimestamp = null;
         if (dateValue) {
             try { matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); }
             catch (e) { console.error("Invalid date:", e); showSaveStatus('Error: Invalid Date format.', true); return; }
         } else {
              showSaveStatus('Error: Match Date & Time is required.', true); return;
         }
         const newMatchData = {
             date: matchDateTimestamp,
             type: document.getElementById('new-match-type').value.trim(),
             team1: { name: document.getElementById('new-match-team1-name').value.trim(), logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase() },
             team2: { name: document.getElementById('new-match-team2-name').value.trim(), logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase() },
             venue: document.getElementById('new-match-venue').value.trim(),
             streamLink: document.getElementById('new-match-stream').value.trim()
         };
         if (!newMatchData.type || !newMatchData.team1.name || !newMatchData.team2.name) {
             showSaveStatus('Error: Type, Team 1 Name, and Team 2 Name are required.', true); return;
         }
         console.log("New match validated:", newMatchData);
         showSaveStatus('Saving new match...', false);
         try {
             const docRef = await db.collection('matches').add(newMatchData);
             console.log("New match added ID:", docRef.id); showSaveStatus('New match added!', false);
             addMatchForm.classList.add('hidden');
             document.getElementById('new-match-date').value = '';
             document.getElementById('new-match-type').value = '';
             document.getElementById('new-match-team1-name').value = '';
             document.getElementById('new-match-team1-logo').value = '';
             document.getElementById('new-match-team2-name').value = '';
             document.getElementById('new-match-team2-logo').value = '';
             document.getElementById('new-match-venue').value = '';
             document.getElementById('new-match-stream').value = 'https://www.twitch.tv/poxelcompetitive/';
             loadMatchesAdmin();
         } catch (error) {
             console.error("Error adding match:", error);
             showSaveStatus(`Error adding match: ${error.message}`, true);
         }
    });
    saveMatchesChangesButton.addEventListener('click', async () => {
        console.log("Attempting to save ALL match changes...");
         const updates = [];
         let errorsFound = false;
         document.querySelectorAll('#matches-list .match-editor').forEach(editor => {
             const id = editor.dataset.id;
             if (!id) return;
             const matchData = { team1: {}, team2: {} };
             let hasError = false;
             const dateInput = editor.querySelector('input[data-field="date"]');
             if (dateInput) {
                 const dateValue = dateInput.value;
                 if (dateValue) {
                     try {
                         matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue));
                     } catch (e) {
                         console.error(`Invalid date format for match ${id}: ${dateValue}`, e);
                         showSaveStatus(`Error: Invalid date for match ${id}. Fix and save again.`, true);
                         hasError = true;
                         errorsFound = true;
                     }
                 } else {
                      console.warn(`Date missing for match ${id}. Setting to null.`);
                      matchData.date = null;
                 }
             } else {
                 console.warn(`Date input not found for match ${id}`);
             }
             if (!hasError) {
                 editor.querySelectorAll('input[type="text"], input[type="number"]').forEach(input => {
                     if (input.dataset.field === 'date') return;
                     const fieldPath = input.dataset.field;
                     let value = input.value.trim();
                     if (input.type === "text" && input.maxLength === 2) { value = value.toUpperCase(); }
                     if (fieldPath?.includes('.')) {
                         const parts = fieldPath.split('.');
                         if (parts.length === 2) {
                             if (!matchData[parts[0]]) matchData[parts[0]] = {};
                             matchData[parts[0]][parts[1]] = value;
                         }
                     } else if (fieldPath) {
                         matchData[fieldPath] = value;
                     }
                 });
                 if (!matchData.type || !matchData.team1?.name || !matchData.team2?.name) {
                     console.error(`Missing required field(s) for match ${id}`);
                      showSaveStatus(`Error: Missing Type or Team Names for match ${id}.`, true);
                      hasError = true;
                      errorsFound = true;
                 }
             }
             if (!hasError) {
                 console.log(`Queueing update for Match ID ${id}:`, matchData);
                 updates.push({ id: id, data: matchData });
             }
         });
         if (errorsFound) {
             showSaveStatus('Errors found. Please fix them before saving all changes.', true);
             console.log("Save aborted due to validation errors.");
             return;
         }
         if (updates.length === 0) {
             showSaveStatus('No changes detected or queued for saving.', false);
             return;
         }
         console.log(`Proceeding with batch update for ${updates.length} matches.`);
         showSaveStatus(`Saving ${updates.length} match changes...`, false);
         const batch = db.batch();
         updates.forEach(update => {
             const docRef = db.collection('matches').doc(update.id);
             batch.update(docRef, update.data);
         });
         try {
             await batch.commit();
             console.log("Batch update successful.");
             showSaveStatus(`${updates.length} match(es) updated successfully!`, false);
             loadMatchesAdmin();
         } catch (error) {
             console.error("Error committing batch update for matches:", error);
             showSaveStatus(`Error saving match changes: ${error.message}`, true);
         }
     });

    // --- Leaderboard Load/Save/Delete ---
    async function loadLeaderboardAdmin() {
        if (!leaderboardBodyAdmin) { console.error("loadLeaderboardAdmin: leaderboardBodyAdmin element not found"); return; }
        leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>';
         console.log("Loading leaderboard from Firestore...");
         try {
             const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get();
             console.log(`Found ${snapshot.size} players.`);
             leaderboardBodyAdmin.innerHTML = '';
             let rank = 1;
             if (snapshot.empty) {
                 leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>';
                 return;
             }
             snapshot.forEach(doc => {
                 const player = { id: doc.id, ...doc.data() };
                 const row = document.createElement('tr');
                 row.dataset.id = player.id;
                  const matches = player.matches ?? 0;
                  const wins = player.wins ?? 0;
                  const losses = player.losses ?? 0;
                  const points = player.points ?? 0;
                  row.innerHTML = `
                      <td>${rank++}</td>
                      <td><input type="text" value="${player.name || ''}" data-field="name" required></td>
                      <td><input type="text" value="${player.avatar || ''}" data-field="avatar" maxlength="2"></td>
                      <td><input type="number" value="${matches}" data-field="matches" min="0"></td>
                      <td><input type="number" value="${wins}" data-field="wins" min="0"></td>
                      <td><input type="number" value="${losses}" data-field="losses" min="0"></td>
                      <td><input type="number" value="${points}" data-field="points"></td>
                       <td><button class="delete-player-button" data-id="${player.id}">Delete</button></td>
                  `;
                 leaderboardBodyAdmin.appendChild(row);
             });
             attachPlayerDeleteListeners();

         } catch (error) {
             console.error("Error loading leaderboard:", error);
             leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:red;">Error loading leaderboard.</td></tr>';
         }
     }
    function attachPlayerDeleteListeners() {
        console.log("Attaching player delete listeners...");
         const buttons = document.querySelectorAll('#leaderboard-body-admin .delete-player-button');
          console.log(`Found ${buttons.length} delete player buttons.`);

          buttons.forEach(button => {
             const newButton = button.cloneNode(true);
             button.parentNode.replaceChild(newButton, button);

             newButton.addEventListener('click', async (e) => {
                 const id = e.target.dataset.id;
                 if (!id) { console.error("Delete Error: No ID found on button dataset."); return; }
                 const row = e.target.closest('tr');
                 const nameInput = row ? row.querySelector('input[data-field="name"]') : null;
                 const playerName = nameInput ? nameInput.value : `Player ID: ${id}`;
                 console.log(`Attempting to delete player: ${playerName} (ID: ${id})`);
                 if (confirm(`Are you sure you want to delete player "${playerName}"? This action cannot be undone.`)) {
                     try {
                         await db.collection('leaderboard').doc(id).delete();
                          console.log(`Player ${id} deleted from Firestore.`);
                         showSaveStatus('Player deleted successfully!', false);
                         loadLeaderboardAdmin();
                     } catch (error) {
                         console.error(`Error deleting player ${id} from Firestore:`, error);
                         showSaveStatus(`Error deleting player: ${error.message}`, true);
                     }
                 } else {
                     console.log("Player deletion cancelled.");
                 }
             });
         });
     }
    addPlayerButton.addEventListener('click', () => {
        console.log("Toggle Add New Player form.");
          if (addPlayerForm) addPlayerForm.classList.toggle('hidden');
    });

    // <<< --- MODIFIED saveNewPlayerButton Listener --- >>>
    saveNewPlayerButton.addEventListener('click', async () => {
        console.log("Attempting to save new player to leaderboard...");
        showSaveStatus('Processing new player...', false); // Initial status
        saveNewPlayerButton.disabled = true; // Disable button during processing

        const nameInput = document.getElementById('new-player-name');
        const avatarInput = document.getElementById('new-player-avatar');
        const matchesInput = document.getElementById('new-player-matches');
        const winsInput = document.getElementById('new-player-wins');
        const lossesInput = document.getElementById('new-player-losses');
        const pointsInput = document.getElementById('new-player-points');

        if (!nameInput || !avatarInput || !matchesInput || !winsInput || !lossesInput || !pointsInput) {
            console.error("Save New Player Error: Input element(s) missing.");
            showSaveStatus('Error: Could not find all player form fields.', true);
            saveNewPlayerButton.disabled = false; // Re-enable button
            return;
        }

        const name = nameInput.value.trim();
        const avatar = avatarInput.value.trim().toUpperCase();
        const matches = parseInt(matchesInput.value) || 0;
        const wins = parseInt(winsInput.value) || 0;
        const losses = parseInt(lossesInput.value) || 0;
        const points = parseInt(pointsInput.value) || 0;

        // --- Validation ---
        if (!name) {
            console.warn("Validation fail: Player Name is required.");
            showSaveStatus('Error: Player Name is required.', true);
            nameInput.focus();
            saveNewPlayerButton.disabled = false;
            return;
        }
        if (isNaN(matches) || isNaN(wins) || isNaN(losses) || isNaN(points)) {
            console.warn("Validation fail: Non-numeric value entered for stats.");
            showSaveStatus('Error: Matches, Wins, Losses, and Points must be numbers.', true);
            saveNewPlayerButton.disabled = false;
            return;
        }

        const newPlayerData = {
            name: name, // Keep name in leaderboard doc for easier viewing/sorting
            avatar: avatar,
            matches: Math.max(0, matches),
            wins: Math.max(0, wins),
            losses: Math.max(0, losses),
            points: points
        };

        console.log("New player data validated:", newPlayerData);

        // --- Find User UID by Display Name ---
        let targetUID = null;
        try {
            showSaveStatus(`Searching for user '${name}'...`, false);
            console.log(`Querying users collection for displayName == "${name}"`);

            // Query the 'users' collection
            const userQuery = db.collection('users').where('displayName', '==', name).limit(2); // Limit 2 to detect duplicates
            const querySnapshot = await userQuery.get();

            if (querySnapshot.empty) {
                console.warn(`No user found with displayName "${name}".`);
                showSaveStatus(`Error: No registered user found with the name "${name}". Player must sign up first.`, true);
                saveNewPlayerButton.disabled = false;
                return; // Stop execution
            } else if (querySnapshot.size > 1) {
                console.warn(`Multiple users found with displayName "${name}". Cannot determine correct UID.`);
                showSaveStatus(`Error: Multiple users found with the name "${name}". Please ensure unique usernames or contact support.`, true);
                saveNewPlayerButton.disabled = false;
                return; // Stop execution
            } else {
                // Exactly one user found
                targetUID = querySnapshot.docs[0].id;
                console.log(`Found user with matching displayName. UID: ${targetUID}`);
            }

        } catch (error) {
            console.error("Error querying user collection:", error);
            showSaveStatus(`Error searching for user: ${error.message}`, true);
            saveNewPlayerButton.disabled = false;
            return;
        }

        // --- Save to Leaderboard using the found UID ---
        if (targetUID) {
            try {
                showSaveStatus(`Saving leaderboard data for UID ${targetUID}...`, false);
                // Use .set() to create or overwrite the document with the specific UID
                await db.collection('leaderboard').doc(targetUID).set(newPlayerData);

                console.log(`Leaderboard document set successfully for UID: ${targetUID}`);
                showSaveStatus('New player added to leaderboard successfully!', false);

                // Hide form and reset fields
                addPlayerForm.classList.add('hidden');
                nameInput.value = '';
                avatarInput.value = '';
                matchesInput.value = '0';
                winsInput.value = '0';
                lossesInput.value = '0';
                pointsInput.value = '0';

                loadLeaderboardAdmin(); // Refresh the leaderboard view

            } catch (error) {
                console.error(`Error setting leaderboard document for UID ${targetUID}:`, error);
                showSaveStatus(`Error saving player to leaderboard: ${error.message}`, true);
            } finally {
                 saveNewPlayerButton.disabled = false; // Re-enable button
            }
        } else {
            // This case should theoretically be caught by the earlier checks, but as a safeguard:
            console.error("Failed to obtain target UID even after checks. Aborting save.");
            showSaveStatus('Error: Could not determine the user ID. Save aborted.', true);
            saveNewPlayerButton.disabled = false;
        }
    });
    // <<< --- END MODIFIED saveNewPlayerButton Listener --- >>>

    saveLeaderboardChangesButton.addEventListener('click', async () => {
        console.log("Attempting to save all leaderboard changes...");
        const updates = [];
        let errorsFound = false;

        document.querySelectorAll('#leaderboard-body-admin tr').forEach(row => {
            const id = row.dataset.id;
            if (!id) return;

            const playerData = {};
            let hasRowError = false;

            row.querySelectorAll('input').forEach(input => {
                const field = input.dataset.field;
                if (!field) return;

                let value = input.value.trim();

                if (input.type === 'number') {
                    const parsedValue = parseInt(value);
                    if (isNaN(parsedValue)) {
                        console.error(`Invalid number format for player ${id}, field ${field}: "${value}"`);
                        showSaveStatus(`Error: Invalid number for ${field} in row for ID ${id}.`, true);
                        hasRowError = true;
                        errorsFound = true;
                        value = 0;
                    } else {
                         if (field === 'matches' || field === 'wins' || field === 'losses') {
                             value = Math.max(0, parsedValue);
                         } else {
                             value = parsedValue;
                         }
                    }
                } else if (input.type === 'text') {
                    if (field === 'name' && !value) {
                        console.error(`Player Name cannot be empty for ID ${id}.`);
                         showSaveStatus(`Error: Player Name is required for ID ${id}.`, true);
                         hasRowError = true;
                         errorsFound = true;
                    }
                    if (field === 'avatar') {
                        value = value.toUpperCase();
                    }
                }
                 if (!errorsFound || input.type !== 'number' || !isNaN(parseInt(input.value))) {
                     playerData[field] = value;
                 }
            });
            if (id && !hasRowError) {
                console.log(`Queueing update for Player ID ${id}:`, playerData);
                updates.push({ id: id, data: playerData });
            }
        });

        if (errorsFound) {
             showSaveStatus('Errors found in leaderboard data. Please fix them before saving.', true);
            console.log("Save aborted due to validation errors in leaderboard.");
            return;
        }

        if (updates.length === 0) {
            console.log("No valid leaderboard changes detected to save.");
            showSaveStatus('No changes detected or ready to save.', false);
            return;
        }

        console.log(`Proceeding with batch update for ${updates.length} players.`);
        showSaveStatus(`Saving ${updates.length} player changes...`, false);
        const batch = db.batch();
        updates.forEach(update => {
            const docRef = db.collection('leaderboard').doc(update.id);
            batch.update(docRef, update.data);
        });

        try {
            await batch.commit();
            console.log("Leaderboard batch update successful.");
            showSaveStatus(`${updates.length} player(s) updated successfully!`, false);
            loadLeaderboardAdmin();
        } catch (error) {
            console.error("Error committing batch update for leaderboard:", error);
            showSaveStatus(`Error saving leaderboard changes: ${error.message}`, true);
        }
    });

    // --- Bracket Load / Render / Save ---
    async function loadBracketAdmin(bracketType = 'pro') {
        if (!bracketEditor || !bracketLoadingIndicator) { console.error("loadBracketAdmin: necessary bracket elements not found"); return; }
        currentBracketType = bracketType;
        bracketEditor.dataset.type = bracketType;
        bracketLoadingIndicator.classList.remove('hidden');
        bracketLoadingIndicator.textContent = `Loading ${bracketType} bracket...`;
        bracketEditor.innerHTML = '';
        console.log(`--- Loading bracket: ${bracketType} ---`);
        try {
            const docRef = db.collection('brackets').doc(bracketType);
            const docSnap = await docRef.get();
            console.log(`[${bracketType}] Document snapshot received. Exists: ${docSnap.exists}`);
            if (docSnap.exists) {
                currentBracketData = docSnap.data();
                if (!currentBracketData || typeof currentBracketData !== 'object') currentBracketData = {};
                if (!Array.isArray(currentBracketData.rounds)) currentBracketData.rounds = [];
                 currentBracketData.rounds.forEach(round => {
                      if (!round || typeof round !== 'object') round = { name: 'Unnamed Round', matches: [] };
                     if (!Array.isArray(round.matches)) round.matches = [];
                      round.matches.forEach(match => {
                         if (!match || typeof match !== 'object') match = {};
                         if (!match.team1 || typeof match.team1 !== 'object') match.team1 = { name: '', score: null };
                         if (!match.team2 || typeof match.team2 !== 'object') match.team2 = { name: '', score: null };
                         match.team1.score = (match.team1.score === undefined || match.team1.score === '') ? null : Number(match.team1.score);
                         match.team2.score = (match.team2.score === undefined || match.team2.score === '') ? null : Number(match.team2.score);
                         match.completed = !!match.completed;
                      });
                 });
                console.log(`[${bracketType}] Loaded and sanitized bracket data into state:`, JSON.parse(JSON.stringify(currentBracketData)));
            } else {
                console.log(`[${bracketType}] No bracket data found. Initializing empty state.`);
                currentBracketData = { rounds: [] };
            }
            renderBracketEditor();
            console.log(`--- Finished loading bracket: ${bracketType} successfully ---`);
        } catch (error) {
            console.error(`--- ERROR loading ${bracketType} bracket: ---`, error);
            bracketEditor.innerHTML = `<p style="color:red;">Error loading ${bracketType} bracket: ${error.message}. Check console.</p>`;
             currentBracketData = { rounds: [] };
        } finally {
            bracketLoadingIndicator.classList.add('hidden');
        }
     }
    function renderBracketEditor() {
        console.log(`Rendering bracket editor from state for ${currentBracketType}. Data:`, JSON.parse(JSON.stringify(currentBracketData)));
         if (!bracketEditor) { console.error("renderBracketEditor: bracketEditor element not found!"); return; }
         bracketEditor.innerHTML = '';
         bracketEditor.dataset.type = currentBracketType;
         const rounds = currentBracketData.rounds || [];
         if (rounds.length === 0) {
             console.log("No rounds in state. Displaying 'No rounds' message.");
             const placeholder = document.createElement('p');
             placeholder.textContent = 'No rounds in this bracket yet. Use "Add New Round" below.';
             placeholder.style.padding = '20px';
             placeholder.style.textAlign = 'center';
             placeholder.style.color = 'var(--text-secondary)';
             bracketEditor.appendChild(placeholder);
         } else {
             console.log(`Rendering ${rounds.length} rounds from state...`);
             rounds.forEach((round, roundIndex) => {
                 const roundColumnDiv = document.createElement('div');
                 roundColumnDiv.classList.add('bracket-round-column');
                 roundColumnDiv.dataset.roundIndex = roundIndex;
                  const roundName = round && typeof round === 'object' && round.name ? round.name : `Round ${roundIndex + 1}`;
                 roundColumnDiv.innerHTML = `
                     <h4>
                         <input type="text" value="${roundName}" class="round-name" placeholder="Round Name" data-round-index="${roundIndex}" data-field="name" title="Round Name">
                         <button class="delete-round-button" data-round-index="${roundIndex}" title="Delete this entire round">Delete Round</button>
                     </h4>
                     <div class="matches-in-round"></div>
                     <button class="add-match-to-round-button" data-round-index="${roundIndex}" title="Add a new match to this round">Add Match</button>
                 `;
                 const matchesContainer = roundColumnDiv.querySelector('.matches-in-round');
                 const matches = round && Array.isArray(round.matches) ? round.matches : [];
                 if (matches.length > 0) {
                      console.log(`Rendering ${matches.length} matches for round ${roundIndex + 1}...`);
                     matches.forEach((match, matchIndex) => {
                         const matchDiv = renderBracketMatchEditor(match || {}, roundIndex, matchIndex);
                         if (matchDiv && matchesContainer) {
                             matchesContainer.appendChild(matchDiv);
                         } else {
                             console.error("Error: Couldn't append matchDiv, container or div is null", matchDiv, matchesContainer);
                         }
                     });
                 } else {
                      console.log(`No matches for round ${roundIndex + 1}.`);
                     const p = document.createElement('p');
                     p.textContent = 'No matches yet in this round.';
                     p.style.textAlign = 'center';
                     p.style.fontSize = '0.9em';
                     p.style.color = 'var(--text-secondary)';
                     matchesContainer.appendChild(p);
                 }
                 bracketEditor.appendChild(roundColumnDiv);
             });
         }
         console.log("Attaching bracket editor listeners after rendering.");
         attachBracketEditorListeners();
     }
    function renderBracketMatchEditor(match, roundIndex, matchIndex) {
        const matchDiv = document.createElement('div');
        matchDiv.classList.add('bracket-match-editor');
        matchDiv.dataset.roundIndex = roundIndex;
        matchDiv.dataset.matchIndex = matchIndex;
        const team1Name = match?.team1?.name || '';
        const team1Score = (match?.team1?.score === null || match?.team1?.score === undefined) ? '' : match.team1.score;
        const team2Name = match?.team2?.name || '';
        const team2Score = (match?.team2?.score === null || match?.team2?.score === undefined) ? '' : match.team2.score;
        const winnerName = match?.winnerName || '';
        const completed = match?.completed || false;
        matchDiv.innerHTML = `
            <h5>Match ${matchIndex + 1}
            <button class="delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}" title="Delete this match">Delete</button>
            </h5>
            <label>Team 1 Name:</label> <input type="text" value="${team1Name}" class="bracket-team1-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.name">
            <label>Team 1 Score:</label> <input type="number" value="${team1Score}" class="bracket-team1-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.score" min="0">
            <label>Team 2 Name:</label> <input type="text" value="${team2Name}" class="bracket-team2-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.name">
            <label>Team 2 Score:</label> <input type="number" value="${team2Score}" class="bracket-team2-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.score" min="0">
            <label>Winner (Exact name or blank):</label> <input type="text" value="${winnerName}" class="bracket-winner-name" placeholder="Enter winning team name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="winnerName">
            <label class="checkbox-label">
                <input type="checkbox" ${completed ? 'checked' : ''} class="bracket-match-completed" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="completed"> Completed
            </label>
        `;
        return matchDiv;
     }
    function attachBracketEditorListeners() {
        console.log("Attaching/Re-attaching listeners for bracket editor actions.");
        if (!bracketEditor) { console.error("Cannot attach listeners: bracketEditor not found."); return; }
        bracketEditor.removeEventListener('click', handleBracketButtonClick);
        bracketEditor.addEventListener('click', handleBracketButtonClick);
        bracketEditor.removeEventListener('input', handleBracketInput);
        bracketEditor.removeEventListener('change', handleBracketInput);
        bracketEditor.addEventListener('input', handleBracketInput);
        bracketEditor.addEventListener('change', handleBracketInput);
        if (addRoundButton) {
             addRoundButton.removeEventListener('click', handleAddRoundClick);
             addRoundButton.addEventListener('click', handleAddRoundClick);
        } else { console.error("Add Round Button not found."); }
        if (saveBracketChangesButton) {
             saveBracketChangesButton.removeEventListener('click', handleSaveBracketClick);
             saveBracketChangesButton.addEventListener('click', handleSaveBracketClick);
        } else { console.error("Save Bracket Button not found."); }
        if (bracketSelect) {
             bracketSelect.removeEventListener('change', handleBracketSelectChange);
             bracketSelect.addEventListener('change', handleBracketSelectChange);
        } else { console.error("Bracket Select dropdown not found."); }
        console.log("Bracket editor listeners attached.");
    }
    function handleBracketSelectChange(e) {
        const newType = e.target.value;
        console.log(`Bracket selection changed to: ${newType}`);
        loadBracketAdmin(newType);
     }
    function handleAddRoundClick() {
        console.log("Add Round button clicked. Adding to state.");
        if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) {
            console.warn("currentBracketData.rounds is not an array. Initializing.");
            currentBracketData = { rounds: [] };
        }
        currentBracketData.rounds.push({ name: `Round ${currentBracketData.rounds.length + 1}`, matches: [] });
        console.log("Round added to state. Re-rendering editor.");
        renderBracketEditor();
     }
    async function handleSaveBracketClick() {
        console.log(`Attempting to save bracket changes for: ${currentBracketType}. State data before final prep:`, JSON.parse(JSON.stringify(currentBracketData)));
        if (!currentBracketType) { console.error("Save Bracket Error: No bracket type specified."); showSaveStatus('Error: Cannot determine which bracket to save.', true); return; }
        if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) {
            console.error("Save Bracket Error: Bracket data is invalid or missing.");
            showSaveStatus('Error: Bracket data structure is invalid. Cannot save.', true);
            return;
        }
        let dataToSave;
        try { dataToSave = JSON.parse(JSON.stringify(currentBracketData)); }
        catch (e) { console.error("Save Bracket Error: Failed to clone bracket data.", e); showSaveStatus('Error: Failed to prepare bracket data for saving.', true); return; }
        let validationError = false;
        dataToSave.rounds.forEach((round, roundIndex) => {
             if (!round || typeof round !== 'object') { console.error(`Validation Error: Invalid round object at index ${roundIndex}.`); showSaveStatus(`Error: Invalid data found in Round ${roundIndex + 1}. Save aborted.`, true); validationError = true; return; }
            round.name = round.name ? round.name.trim() : `Round ${roundIndex + 1}`;
            if (!Array.isArray(round.matches)) { console.warn(`Round ${roundIndex + 1} ('${round.name}') has invalid matches array. Setting to empty.`); round.matches = []; }
            round.matches.forEach((match, matchIndex) => {
                 if (!match || typeof match !== 'object') { console.error(`Validation Error: Invalid match object at R${roundIndex+1} M${matchIndex+1}.`); showSaveStatus(`Error: Invalid data found in match ${matchIndex + 1}, Round ${roundIndex + 1}. Save aborted.`, true); validationError = true; return; }
                 if (!match.team1 || typeof match.team1 !== 'object') match.team1 = {};
                 if (!match.team2 || typeof match.team2 !== 'object') match.team2 = {};
                 match.team1.name = match.team1.name ? match.team1.name.trim() : '';
                 match.team2.name = match.team2.name ? match.team2.name.trim() : '';
                 match.team1.score = (match.team1.score === '' || match.team1.score === undefined || match.team1.score === null) ? null : Number(match.team1.score);
                 match.team2.score = (match.team2.score === '' || match.team2.score === undefined || match.team2.score === null) ? null : Number(match.team2.score);
                 if (isNaN(match.team1.score) && match.team1.score !== null) { console.error(`Validation Error: Invalid Team 1 score for R${roundIndex+1} M${matchIndex+1}: "${match.team1.score}"`); showSaveStatus(`Error: Invalid score T1 in R${roundIndex+1} M${matchIndex+1}. Save aborted.`, true); validationError = true; }
                  if (isNaN(match.team2.score) && match.team2.score !== null) { console.error(`Validation Error: Invalid Team 2 score for R${roundIndex+1} M${matchIndex+1}: "${match.team2.score}"`); showSaveStatus(`Error: Invalid score T2 in R${roundIndex+1} M${matchIndex+1}. Save aborted.`, true); validationError = true; }
                 match.completed = !!match.completed;
                 match.winnerName = match.winnerName ? match.winnerName.trim() : '';
                match.winner = null;
                if (match.completed && match.winnerName) {
                     const winnerNameLower = match.winnerName.toLowerCase();
                     const team1NameLower = match.team1.name?.toLowerCase();
                     const team2NameLower = match.team2.name?.toLowerCase();
                    if (team1NameLower && winnerNameLower === team1NameLower) { match.winner = match.team1.name; }
                    else if (team2NameLower && winnerNameLower === team2NameLower) { match.winner = match.team2.name; }
                    else { console.warn(`Winner name "${match.winnerName}" in R${roundIndex+1} M${matchIndex+1} does not exactly match either team name ("${match.team1.name}" or "${match.team2.name}"). 'winner' field will be null.`); }
                } else if (match.completed && !match.winnerName) { console.warn(`Match R${roundIndex+1} M${matchIndex+1} is marked completed, but no winner name was entered. 'winner' field will be null.`); }
            });
        });
        if (validationError) { console.error("Save aborted due to validation errors detected during final preparation."); return; }
        console.log(`Saving validated and prepared bracket data for ${currentBracketType}:`, JSON.parse(JSON.stringify(dataToSave)));
        showSaveStatus(`Saving ${currentBracketType} bracket changes...`, false);
        try {
            await db.collection('brackets').doc(currentBracketType).set(dataToSave);
            console.log("Bracket saved successfully to Firestore.");
            showSaveStatus(`${currentBracketType} bracket saved successfully!`, false);
        }
        catch (error) {
            console.error(`Error saving ${currentBracketType} bracket to Firestore:`, error);
            showSaveStatus(`Error saving bracket: ${error.message}`, true);
        }
     }
    function handleBracketButtonClick(event) {
        const target = event.target;
        if (target.classList.contains('delete-round-button') && target.dataset.roundIndex !== undefined) {
            const roundIndex = parseInt(target.dataset.roundIndex);
             console.log("Delegated click: Delete Round button handled for index:", roundIndex);
            if (!isNaN(roundIndex)) { deleteBracketRoundFromState(roundIndex); }
            else { console.error("Invalid round index for delete:", target.dataset.roundIndex); }
        } else if (target.classList.contains('add-match-to-round-button') && target.dataset.roundIndex !== undefined) {
            const roundIndex = parseInt(target.dataset.roundIndex);
             console.log("Delegated click: Add Match button handled for round index:", roundIndex);
             if (!isNaN(roundIndex)) { addBracketMatchToState(roundIndex); }
             else { console.error("Invalid round index for add match:", target.dataset.roundIndex); }
        } else if (target.classList.contains('delete-match-from-round-button') && target.dataset.roundIndex !== undefined && target.dataset.matchIndex !== undefined) {
            const roundIndex = parseInt(target.dataset.roundIndex);
            const matchIndex = parseInt(target.dataset.matchIndex);
            console.log("Delegated click: Delete Match button handled for R:", roundIndex, " M:", matchIndex);
            if (!isNaN(roundIndex) && !isNaN(matchIndex)) { deleteBracketMatchFromState(roundIndex, matchIndex); }
            else { console.error("Invalid indices for delete match:", target.dataset.roundIndex, target.dataset.matchIndex); }
        }
     }
    function handleBracketInput(event) {
        const target = event.target;
        if (!target || !(target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) return;
        if (!target.closest('.bracket-round-column')) return;
        const roundIndexStr = target.dataset.roundIndex;
        const matchIndexStr = target.dataset.matchIndex;
        const field = target.dataset.field;
        if (roundIndexStr === undefined || field === undefined) { return; }
        const roundIndex = parseInt(roundIndexStr);
        const matchIndex = (matchIndexStr !== undefined) ? parseInt(matchIndexStr) : null;
        if (isNaN(roundIndex) || (matchIndexStr !== undefined && isNaN(matchIndex))) { console.error("Invalid index detected in input handler:", roundIndexStr, matchIndexStr); return; }
        try {
             if (!currentBracketData || !Array.isArray(currentBracketData.rounds) || !currentBracketData.rounds[roundIndex]) { console.warn(`State Error: Round ${roundIndex} not found in currentBracketData.rounds`); return; }
             const round = currentBracketData.rounds[roundIndex];
             if (matchIndex === null) {
                 if (field === 'name') { console.log(`Updating round ${roundIndex} name to: ${target.value}`); round.name = target.value.trim(); }
                 else { console.warn(`Unhandled round-level field: ${field}`); }
             } else {
                 if (!round.matches || !Array.isArray(round.matches) || !round.matches[matchIndex]) { console.warn(`State Error: Match ${matchIndex} not found in round ${roundIndex}`); return; }
                 const match = round.matches[matchIndex];
                 let value;
                 if (target.type === 'checkbox') { value = target.checked; }
                 else if (target.type === 'number') { value = target.value === '' ? null : parseInt(target.value); if (isNaN(value) && target.value !== '') { console.warn(`Could not parse number for field ${field}: ${target.value}. Storing as null.`); value = null; } }
                 else { value = target.value; }
                 console.log(`Updating state: R${roundIndex} M${matchIndex} field "${field}" to:`, value);
                 if (field.includes('.')) {
                     const parts = field.split('.');
                     if (parts.length === 2) { if (!match[parts[0]] || typeof match[parts[0]] !== 'object') { match[parts[0]] = {}; } match[parts[0]][parts[1]] = value; }
                     else { console.warn(`Unhandled complex field path in input handler: ${field}`); }
                 } else { match[field] = value; }
             }
        } catch (error) { console.error("Error updating state from input:", error, { roundIndex, matchIndex, field }); }
     }
    function deleteBracketRoundFromState(roundIndex) {
        console.log(`Attempting to delete round index: ${roundIndex} from state`);
         if (!currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length) { console.error(`Invalid round index ${roundIndex} for deletion from state.`); alert(`Error: Cannot delete round ${roundIndex + 1} - index out of bounds.`); return; }
         const roundNameToDelete = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
         if (confirm(`Are you sure you want to delete "${roundNameToDelete}"? This will also delete all matches within it. This change is temporary until saved.`)) {
             currentBracketData.rounds.splice(roundIndex, 1);
             console.log(`Removed round index: ${roundIndex} from state. New state has ${currentBracketData.rounds.length} rounds.`);
             renderBracketEditor();
         } else { console.log("Deletion of round cancelled."); }
     }
    function addBracketMatchToState(roundIndex) {
        console.log(`Attempting to add match to round index: ${roundIndex} in state`);
         if (!currentBracketData || !currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length) { console.error(`Invalid round index ${roundIndex} for adding match to state.`); alert(`Error: Cannot add match - could not find Round ${roundIndex + 1} in the data.`); return; }
         if (!Array.isArray(currentBracketData.rounds[roundIndex].matches)) { console.warn(`Matches array missing for round ${roundIndex}. Initializing.`); currentBracketData.rounds[roundIndex].matches = []; }
         const newMatch = { team1: { name: '', score: null }, team2: { name: '', score: null }, winnerName: '', winner: null, completed: false };
         currentBracketData.rounds[roundIndex].matches.push(newMatch);
         const newMatchIndex = currentBracketData.rounds[roundIndex].matches.length - 1;
         console.log(`Added new match (index ${newMatchIndex}) to round ${roundIndex} in state.`);
         renderBracketEditor();
    }
    function deleteBracketMatchFromState(roundIndex, matchIndex) {
        console.log(`Attempting to delete match index ${matchIndex} from round index ${roundIndex} from state.`);
         if (!currentBracketData || !currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length || !currentBracketData.rounds[roundIndex].matches || !Array.isArray(currentBracketData.rounds[roundIndex].matches) || matchIndex < 0 || matchIndex >= currentBracketData.rounds[roundIndex].matches.length) { console.error(`Invalid indices R${roundIndex} M${matchIndex} or invalid data structure for deletion from state.`); alert(`Error: Could not find Match ${matchIndex + 1} in Round ${roundIndex + 1} to delete.`); return; }
        const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
        if (confirm(`Are you sure you want to delete Match ${matchIndex + 1} from "${roundName}"? This change is temporary until saved.`)) {
            currentBracketData.rounds[roundIndex].matches.splice(matchIndex, 1);
             console.log(`Removed match R${roundIndex} M${matchIndex} from state. Round ${roundIndex} now has ${currentBracketData.rounds[roundIndex].matches.length} matches.`);
            renderBracketEditor();
        } else { console.log("Deletion of match cancelled."); }
    }

    // --- General Save Status ---
    function showSaveStatus(message, isError = false) {
        console.log(`Save Status: ${message} (Error: ${isError})`);
        if (!saveStatus) { console.warn("showSaveStatus: saveStatus element not found."); return; }
        saveStatus.textContent = message;
        saveStatus.style.color = isError ? 'red' : 'lightgreen';
        saveStatus.style.fontWeight = isError ? 'bold' : 'normal';
         if (window.saveStatusTimeout) clearTimeout(window.saveStatusTimeout);
         window.saveStatusTimeout = setTimeout(() => {
             if (saveStatus.textContent === message) {
                 saveStatus.textContent = '';
                 saveStatus.style.color = 'lightgreen';
                 saveStatus.style.fontWeight = 'normal';
             }
         }, isError ? 8000 : 5000);
     }

    // --- Initial Load Call ---
    console.log("Admin script initialized. Waiting for authentication state...");
    document.addEventListener('DOMContentLoaded', () => {
         console.log("DOM Content Loaded. Initializing UI elements if possible.");
    });
    window.addEventListener('beforeunload', (event) => {
        if (currentUserId && auth.currentUser) {
            console.log("beforeunload triggered. Attempting quick presence removal (may not complete).");
            db.collection(PRESENCE_COLLECTION).doc(currentUserId).delete()
                .then(() => console.log("Presence remove request sent on beforeunload."))
                .catch(err => console.warn("Error sending presence remove on beforeunload:", err));
        }
    });

    // --- END OF SCRIPT --- //
</script>

</body>
</html>
