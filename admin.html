     async function loadBracketAdmin(bracketType = 'pro') {
        if (!bracketEditor || !bracketLoadingIndicator) return;
        currentBracketType = bracketType;
        bracketEditor.dataset.type = bracketType;
        bracketLoadingIndicator.classList.remove('hidden');
        bracketLoadingIndicator.textContent = `Loading ${bracketType} bracket...`;
        bracketEditor.innerHTML = ''; // Clear previous bracket content

        try {
            const docRef = db.collection('brackets').doc(bracketType);
            const docSnap = await docRef.get();

            // *** FIX IS HERE: Use .exists as a property, not a function ***
            if (docSnap.exists) { // Corrected line
                currentBracketData = docSnap.data();
                // --- Data Sanitization/Defaulting ---
                if (!currentBracketData || typeof currentBracketData !== 'object') currentBracketData = {};
                if (!Array.isArray(currentBracketData.rounds)) currentBracketData.rounds = [];

                currentBracketData.rounds.forEach((round, rIdx) => {
                    // Default round object if invalid
                    if (!round || typeof round !== 'object') {
                        currentBracketData.rounds[rIdx] = { name: `Round ${rIdx + 1}`, matches: [] };
                        round = currentBracketData.rounds[rIdx]; // Update reference
                    }
                    // Default round name
                    round.name = round.name?.trim() || `Round ${rIdx + 1}`;
                    // Default matches array
                    if (!Array.isArray(round.matches)) round.matches = [];

                    round.matches.forEach((match, mIdx) => {
                         // Default match object if invalid
                         if (!match || typeof match !== 'object') {
                             round.matches[mIdx] = { team1: { name: '', score: null }, team2: { name: '', score: null }, winnerName: '', winner: null, completed: false };
                             match = round.matches[mIdx]; // Update reference
                         }
                         // Default nested team objects
                         if (!match.team1 || typeof match.team1 !== 'object') match.team1 = { name: '', score: null };
                         if (!match.team2 || typeof match.team2 !== 'object') match.team2 = { name: '', score: null };

                         // Default team names and scores (handle undefined, null, empty strings)
                         match.team1.name = match.team1.name ?? '';
                         match.team2.name = match.team2.name ?? '';
                         match.team1.score = (match.team1.score === undefined || match.team1.score === null || match.team1.score === '' || isNaN(Number(match.team1.score))) ? null : Number(match.team1.score);
                         match.team2.score = (match.team2.score === undefined || match.team2.score === null || match.team2.score === '' || isNaN(Number(match.team2.score))) ? null : Number(match.team2.score);

                         // Default other match properties
                         match.winnerName = match.winnerName ?? '';
                         match.completed = !!match.completed; // Ensure boolean
                         match.winner = match.winner ?? null; // Ensure null if not set
                    });
                });
            } else {
                console.log(`${bracketType} bracket document does not exist. Initializing empty structure.`);
                currentBracketData = { rounds: [] }; // Start with empty rounds if no doc exists
            }
            renderBracketEditor(); // Render the sanitized/initialized data
        } catch (error) {
            console.error(`ERROR loading ${bracketType} bracket:`, error);
            bracketEditor.innerHTML = `<p style="color: var(--red-error); text-align: center;">Error loading ${bracketType} bracket: ${error.message}.</p>`;
            currentBracketData = { rounds: [] }; // Reset on error
        } finally {
            bracketLoadingIndicator.classList.add('hidden');
        }
    }
